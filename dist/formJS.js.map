{"version":3,"file":"formJS.js","sources":["../src/lib/library.ts","../src/lib/options.ts","../src/lib/validator.ts","../src/lib/form.ts","../src/lib/instance.ts","../src/index.ts"],"sourcesContent":["/**\n * FormJS library options.\n */\nexport const Library = {\n    name: 'FormJS',\n    version: '1.0.11',\n}\n\n/**\n * FormJS options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const RootOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'ref',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'form',\n                acceptedTypes: ['object', 'string'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return (type === 'string') ? [] : [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'elements',\n                            acceptedTypes: ['object']\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'onsubmit',\n                acceptedTypes: ['object', 'Function'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return [\n                        {\n                            option: 'method',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'url',\n                            acceptedTypes: ['string']\n                        },\n                        {\n                            option: 'includeFormData',\n                            acceptedTypes: ['boolean'],\n                            optional: true,\n                        },\n                        {\n                            option: 'before',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'success',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'error',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'created',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'beforeMount',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'mounted',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            }\n        ];\n    }\n}\n\n/**\n * FormJS Element Options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const ElementOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'validate',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'attributes',\n                acceptedTypes: ['object'],\n\n                requiredOptions(type: null|string = null) {\n                    type;\n                    return [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        }\n                    ]\n                }\n            }\n        ]\n    }\n}\n","import { Library } from './library';\nimport { RootOptionsStructure } from './library';\nimport { ElementOptionsStructure } from './library';\n\n/**\n * A set of options testing functions for the library.\n *\n * These exist for more efficient and useful error reporting and library\n * stability.\n */\nexport const Options = {\n    /**\n     * Method to test all required options against all criteria.\n     * @param {FormJSOptions} options - options object to test with.\n     * @param {Array<object>} - current FormJS instances to test against.\n     */\n    test(options: FormJSOptions, instances: Array<object>)\n    {\n        // Test options exist and correct types on root options...\n        this.testExistsAndTypes(options, RootOptionsStructure.requiredOptions());\n\n        // Test `ref` and `el` are unique across all instances as long as they're\n        // not `undefined`.\n        if (options.ref !== undefined) {\n            this.testIsUniqueInInstances('ref', instances, options.ref);\n        }\n\n        if (options.el !== undefined) {\n            this.testIsUniqueInInstances('el', instances, options.el);\n        }\n\n        // If form is a string...\n        if (typeof options.form === 'string') {\n            // Test that the form is unique across all instances.\n            this.testIsUniqueInInstances('form', instances, options.form);\n        }\n        // Else if an object with `elements` array longer than 0.\n        else if (options.form.elements.length > 0) {\n            // Loop these elements and test options and correct types in them.\n            options.form.elements.forEach((element: object) => {\n                this.testExistsAndTypes(element, ElementOptionsStructure.requiredOptions());\n            });\n        }\n    },\n\n    /**\n     * Method to test if an option is unique in the library instances. This\n     * is a useful because we don't always want repeating vital options. For\n     * example, the same form being bound to twice.\n     *\n     * @param {string} context - context in regards to nesting in the options object.\n     * @param {Array<object>} instances - the current FormJS instances.\n     * @param {any} payload - option to test exists in context.\n     * @return {void}\n     * @throws {Error}\n     */\n    testIsUniqueInInstances(context: string, instances: Array<object>, payload: any): void\n    {\n        // Filter array by picking out matching payloads. If this new array has\n        // a length greater than 1... then we have a match where we shouldn't.\n        //\n        // Throw an error in this case.\n        if (instances.filter(instance => instance[context] === payload).length > 0) {\n            throw `${Library.name} instance with \\`${context}\\`, \\`${payload}\\` is already in use.`;\n        }\n    },\n\n    /**\n     * Method to test the options passed against the structure the library\n     * expects.\n     *\n     * @param {object} options - options passed by user.\n     * @param {Array<object>} - requiredOptions - options structure that is required\n     * by FormJS.\n     * @param {null|string} context - optional context for options to specify nesting.\n     * @return {void}\n     * @throws {Error}\n     */\n    testExistsAndTypes(options: object, requiredOptions: Array<object>, context: null|string = null): void\n    {\n        // Check if we have a context and apply that immediately if so.\n        options = (context !== null) ? options[context] : options;\n\n        // Loop through our required options structure...\n        requiredOptions.forEach((requiredOption: object) => {\n            // First we'll check each required option is in the users options\n            // *unless* it's optional...\n            if (!options.hasOwnProperty(requiredOption['option']) && requiredOption['optional'] === undefined) {\n                // Throwing an error if not present and not optional...\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` required to create new ${Library.name} instance.`;\n            }\n\n            // Then, we'll loop through our accepted types...\n            let typesCorrect = false;\n            requiredOption['acceptedTypes'].some((type: string) => {\n                // ...Checking to see if each one matches the passed type *or*\n                // the passed option doesn't exist in case we're testing an option\n                // that's optional and could not be present.\n                if (typeof options[requiredOption['option']] === type || !options.hasOwnProperty(requiredOption['option'])) {\n                    // Exit out of loop if a type match has been made or\n                    // we're skipping. This signifies the option has passed.\n                    typesCorrect = true;\n                    return typesCorrect;\n                }\n            });\n\n            // After looping, we'll check if any types are incorrect throwing\n            // an error if they are.\n            if (typesCorrect === false) {\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` requires type(s) \\`${requiredOption['acceptedTypes']}\\`. Type \\`${typeof options[requiredOption['option']]}\\` received.`;\n            }\n\n            // Lastly, we'll test for nested required options inside the\n            // current required options.\n            if (requiredOption.hasOwnProperty('requiredOptions')) {\n                // If they exist, re-run this method with updated context and\n                // required options.\n                this.testExistsAndTypes(\n                    options,\n                    requiredOption['requiredOptions'](typeof options[requiredOption['option']]),\n                    requiredOption['option']\n                );\n            }\n\n            // Once here, we're done testing the current context, return.\n            return;\n        });\n    },\n}\n","/**\n * Class to validate form entries.\n */\nexport class Validator\n{\n    // Class variables.\n    form: null|FormObject|string;\n    formData: null|object;\n    validationsToMake: Array<ValidationsToMake> = [];\n\n    /**\n     * Constructor\n     * @param {null|FormObject|string} form - form object.\n     * @param {null\\object} formData - form data object.\n     */\n    constructor(form: null|FormObject|string = null, formData: null|object = null)\n    {\n        this.form = form;\n        this.formData = formData;\n\n        // If we have a form object, then we need to gather the form\n        // validations required into an array to action.\n        if (this.form !== null && typeof this.form !== 'string') {\n            this.sortValidations(this.form);\n        }\n    }\n\n    /**\n     * Method to run validation tests.\n     * @param {null|AdHocValidation} options - options { el: string, rules: string }\n     * @return {Promise<Function>}\n     */\n    async test(options: null|AdHocValidation = null): Promise<Function>\n    {\n        // Sometimes the validation class will be used for ad-hoc validations\n        // by passing an object. If one isn't passed though, we'll assume we're\n        // testing all validations across a whole form...\n        if (options !== null) {\n            this.validationsToMake.push({\n                element: options.el,\n                criteria: options.rules,\n            });\n        }\n\n        // Setting result structure up.\n        let result: any = { passed: true, failed: '' };\n\n        // Create a new labelled `for` loop that then loops through every\n        // validation to make.\n        validationLayer: for (const validation of this.validationsToMake) {\n            // Split validations down into an array of criteria.\n            // Each criteria is seperated by `|`.\n            const allCriteria = validation.criteria.split('|');\n\n            // Then, loop through each criteria and match it to a test.\n            for (const criteria of allCriteria) {\n                if (criteria.includes('minLength:')) {\n                    result = this.testMinLength(validation.element, criteria)\n                }\n                else if (criteria.includes('maxLength:')) {\n                    result = this.testMaxLength(validation.element, criteria);\n                }\n                else if (criteria.includes('isEmail')) {\n                    result = this.testIsEmail(validation.element);\n                }\n                else if (criteria.includes('isNotDisposableEmail')) {\n                    await this.testIsDisposableEmail(validation.element).then(response => result = response);\n                }\n                else if (criteria.includes('hasNumber')) {\n                    result = this.testHasNumber(validation.element);\n                }\n                else if (criteria.includes('hasSymbol')) {\n                    result = this.testHasSymbol(validation.element);\n                }\n                else if (criteria.includes('hasCapital')) {\n                    result = this.testHasCapital(validation.element);\n                }\n                else if (criteria.includes('required')) {\n                    result = this.testRequired(validation.element);\n                }\n\n                // If no matching type, set result to an issue.\n                else {\n                    result = {\n                        passed: false,\n                        failed: `Validation rule \\`${criteria}\\` not recognised`\n                    };\n                }\n\n                // At the end of each loop, check to see if a test failed and if\n                // it did, break to the outer layer...\n                if (result.passed === false) {\n                    break validationLayer;\n                }\n            }\n        }\n\n        // Return promise based on outcome.\n        return (result.passed === true) ?\n            Promise.resolve(result) :\n            Promise.reject(result)\n        ;\n    }\n\n    /**\n     * Method to sort through the validations in the form object and create a\n     * list of them to action.\n     * @param {FormObject|FormObjectElements} form - form object containing elements.\n     * @return {void}\n     */\n    private sortValidations(form: any): void\n    {\n        // Loop through passed form object.\n        form.elements.forEach((element: FormObjectElements) => {\n            // If the element doesn't have property `validate`, return.\n            if (!element.hasOwnProperty('validate')) {\n                return;\n            }\n\n            // Push element id and validation criteria to the list to test.\n            this.validationsToMake.push({\n                element: element.attributes.id,\n                criteria: element.validate,\n            });\n\n            if (element.hasOwnProperty('elements')) {\n                this.sortValidations(element);\n            }\n\n            return;\n        });\n    }\n\n    /**\n     * Method to test element value is at least X length.\n     * @param {string} element - element id.\n     * @param {string} criteria - testing criteria to get min length.\n     * @return {object}\n     */\n    private testMinLength(element: string, criteria: string): object\n    {\n        // Get min length by splitting criteria into an array by `:`. The second\n        // array value will be our min length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        if (document.getElementById(element).value.length  < criteriaValue) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be at least ${criteriaValue} characters!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test element value is not longer than X length.\n     * @param {string} element - element id.\n     * @param {string} criteria - testing criteria to get max length.\n     * @return {object}\n     */\n    private testMaxLength(element: string, criteria: string): object\n    {\n        // Get max length by splitting criteria into an array by `:`. The second\n        // array value will be our max length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        if (document.getElementById(element).value.length  > criteriaValue) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be no more than ${criteriaValue} characters!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value is an email.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testIsEmail(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element).value;\n\n        // Regex from: https://stackoverflow.com/questions/46155/whats-the-best-way-to-validate-an-email-address-in-javascript\n        if (/^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()\\.,;\\s@\\\"]+\\.{0,1})+([^<>()\\.,;:\\s@\\\"]{2,}|[\\d\\.]+))$/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be a valid email!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value is not a disposable email.\n     * @param {string} element - element id\n     * @return {Promise<object>}\n     */\n    private async testIsDisposableEmail(element: string): Promise<object>\n    {\n        // Get the element value and split it by `@` into an array. The second\n        // array element will be the domain to test.\n        const criteriaValue = document.getElementById(element).value.split('@')[1];\n\n        /**\n         * Then we'll call an API which will check an up to date disposable email\n         * database for the passed email domain.\n         * @/// <reference path=\"https://github.com/ivolo/disposable-email-domains\"/>\n         */\n        const result = await fetch(`https://open.kickbox.com/v1/disposable/${criteriaValue}`)\n            .then(response => response.json())\n            .then(data => {\n                return (data.disposable === true) ?\n                {\n                    passed: false,\n                    failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must not be a disposable email!`\n                } :\n                {\n                    passed: true,\n                    failed: ''\n                }\n            })\n        ;\n\n        return Promise.resolve(result);\n    }\n\n    /**\n     * Method to test that the element value has a number.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasNumber(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element).value;\n\n        // Test if element value contains a number.\n        if (/\\d/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a number!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value has a symbol.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasSymbol(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element).value;\n\n        // Test if the element value contains a symbol.\n        if (/[!@#$£%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]+/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a symbol!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value has a capital letter.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasCapital(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element).value\n\n        // Test if element value has a capital letter.\n        if (/[A-Z]/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a capital letter!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test an element value has been entered as the passed element\n     * is required.\n     * @param {string} element - element id.\n     * @return {object}\n     */\n    private testRequired(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element).value;\n\n        // Test if element value length is 0.\n        if (criteriaValue.length <= 0) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} is required and can't be submitted empty!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n}\n","import { Validator } from './validator';\n\n/**\n * A set of functions that help with form processing.\n */\nexport class Form\n{\n    fetchApiParams = {};\n    form: string|FormObject;\n    onsubmit: OnsubmitObject;\n    wrappingEl: string;\n\n    /**\n     * Constructor\n     * @param {string|FormObject} form - form definition.\n     * @param {OnsubmitObject} onsubmit - onsubmit definition.\n     * @param {string} wrappingEl - wrapping element for form.\n     */\n    constructor(form: string|FormObject, onsubmit: OnsubmitObject, wrappingEl: string)\n    {\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.wrappingEl = wrappingEl;\n    }\n\n    /**\n     * Method to create a new form.\n     * @return {Promise<Function>}\n     */\n    create(): Promise<Function>\n    {\n        // Create a new promise...\n        return new Promise((resolve: Function, reject: Function) => {\n            // Reject if wrong type.\n            if (typeof this.form === 'string') {\n                return reject();\n            }\n\n            // Create a new form element and set the ID equal to the passed ID.\n            const form = document.createElement('form');\n            form.setAttribute('id', this.form.id);\n\n            // Append the form to the chosen `el` in the DOM structure.\n            document.getElementById(this.wrappingEl).appendChild(form);\n\n            // All created, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to create elements inside the newly created form!\n     * @param {Array<object>} elementsList - list of elements to create.\n     * @param {string} rootElement - element id to create new elements in.\n     * @return {Promise<Function>}\n     */\n    createInternalElements(rootElement: string): Promise<Function>\n    {\n        return new Promise((resolve: Function, reject: Function) => {\n            // If wrong type, reject.\n            if (typeof this.form === 'string') {\n                return reject();\n            }\n\n            // We'll loop through the elements specified and create new elements\n            // inside the form.\n            this.form.elements.forEach((element: FormObjectElements) => {\n                const elementName = element.el;\n                const formElement = document.createElement(elementName);\n\n                // If element has 'text' property, then we can set the innerHTML.\n                if (element.hasOwnProperty('text')) {\n                    formElement.innerHTML = element.text;\n                }\n\n                // We'll also loop through the attributes passed in each element and\n                // mount those too if they're present.\n                if (element.hasOwnProperty('attributes')) {\n                    for (const [key, value] of Object.entries(element.attributes)) {\n                        formElement.setAttribute(key, value);\n                    }\n                }\n\n                // Once we're done, we'll append the new element to the form.\n                document.getElementById(rootElement).appendChild(formElement);\n\n                // Lastly, let's check if there are any rooted elements to mount too.\n                // If there is, re-run this method.\n                if (element.hasOwnProperty('elements')) {\n                    this.createInternalElements(element.attributes.id);\n                }\n            });\n\n            // All done, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to bind the form to onsubmit event.\n     * @return {Promise<Function>}\n     */\n    bind(): Promise<Function> {\n        return new Promise(() => {\n            // Bind form...\n            document.getElementById((typeof this.form === 'string') ? this.form : this.form.id).addEventListener('submit', (e: any) => this.submit(e));\n\n            // Set up non-dynamic Fetch API params for submission.\n\n            // Here's a list of keys we *cannot* add to the params as they're\n            // reserved for FormJS workings.\n            const blacklistedKeys = ['method', 'url', 'body', 'before', 'success', 'error'];\n            Object.entries(this.onsubmit).forEach(([key,value]) => {\n                // Assume to begin with the key on loop is not blacklisted.\n                let containsBlacklistedKey = false;\n\n                // For every key on loop, loop through blakclisted keys and\n                // look for a match\n                blacklistedKeys.forEach(blacklistedKey => {\n                    if (blacklistedKey == key) {\n                        // Set `containsBlacklistedKey` equal to true and break\n                        // this loop.\n                        containsBlacklistedKey = true;\n                        return;\n                    }\n                });\n\n                // Check to see if the above loop found a match and if it didn't\n                // add the key=>value to the list of params to be used during\n                // submission.\n                if (containsBlacklistedKey === false) {\n                    this.fetchApiParams[key] = value;\n                }\n            });\n        });\n    }\n\n    /**\n     * Method to handle form submissions.\n     * @param {Event} e - event.\n     * @return {void}\n     * @throws {Error}\n     */\n    submit(e: any): void\n    {\n        // Prevent default.\n        e.preventDefault();\n\n        // Before we submit, if there's a a `before` method to run, run it.\n        if (this.onsubmit.before !== undefined) {\n            this.onsubmit.before();\n        }\n\n        // The user can choose to submit the form with or without form data.\n        //\n        // Determine whether or not we need to with the below statement and either\n        // set `formData` equal to the forms data *or* an empty object.\n        const formData = (this.onsubmit.includeFormData === true || this.onsubmit.includeFormData === undefined) ?\n            Object.fromEntries(new FormData(e.target).entries()) :\n            {}\n        ;\n\n        // If form passed as type object, then we could need to run validations\n        // too...\n        this.validate(formData).then(() => {\n            // Create a new Fetch API request with the URL & method from the onsubmit\n            // object and the JSON data from the form.\n            fetch(this.onsubmit.url, {\n                method: this.onsubmit.method,\n                body: JSON.stringify(formData),\n                ...this.fetchApiParams\n\n            }).then((response: any) => {\n                // If the response was not `ok`, catch the error.\n                if (response['ok'] === false) {\n                    throw response;\n                }\n\n                // If a `success` method exists on the onsubmit object, run it\n                // passing the response.\n                if (this.onsubmit.success !== undefined) {\n                    this.onsubmit.success(response);\n                }\n            }).catch((error: object) => {\n                // If an `error` method exists on the onsubmit object, run it.\n                if (this.onsubmit.error !== undefined) {\n                    this.onsubmit.error(error, 'request/response');\n                }\n            });\n        });\n    }\n\n    /**\n     * Method to validate form data against required validation.\n     * @param {object} formData - formData object.\n     * @return {Promise<Function>}\n     */\n    validate(formData: object): Promise<Function>\n    {\n        // Create a new promise to pass or fail validations...\n        return new Promise(async (resolve: Function, reject: Function) => {\n            // Check if our form was made by FormJS or by passing an ID.\n            // This will determine whether we validate or not.\n            //\n            // If made by user and passed as an ID, there won't be any\n            // validations to run at this time, so, resolve early.\n            //\n            // If there was an object, we'll create a new validator instance and\n            // run our tests...\n            return (typeof this.form === 'string') ?\n                resolve() :\n                await new Validator(this.form, formData).test()\n                    // Passed.\n                    .then(() => resolve())\n                    // Failed.\n                    .catch(test => {\n                        if (this.onsubmit.error() !== undefined) {\n                            this.onsubmit.error(test.failed, 'validator');\n                        }\n                        return reject(test.failed);\n                    })\n                ;\n            ;\n        });\n    }\n};\n","import { Form } from './form';\n\n/**\n * FormJS instance – every form = an instance.\n */\nexport class Instance\n{\n    // Class variables.\n    ref: string;\n    el: undefined|string;\n    form: string|FormObject;\n    onsubmit: OnsubmitObject;\n\n    // Lifecycle event hooks.\n    created: undefined|Function;\n    beforeMount: undefined|Function;\n    mounted: undefined|Function;\n\n    // One line methods...\n    getAllElements = (): Array<Element> => (typeof this.form === 'object') ? [...document.getElementById(this.form.id).children] : [...document.getElementById(this.form).children];\n    unmount = (): void => document.getElementById(this.form['id']).remove();\n\n    /**\n     * Constructor\n     * @param {string} ref - form instance reference.\n     * @param {undefined|string} el - element to attach the form to.\n     * @param {string|Form} form - form object containing what the form needs to look like.\n     * @param {OnsubmitObject} onsubmit - onsubmit object containing what needs to happen when the form is submitted.\n     */\n    constructor(\n        ref: string,\n        el: undefined|string,\n        form: string|FormObject,\n        onsubmit: OnsubmitObject,\n        created: undefined|Function,\n        beforeMount: undefined|Function,\n        mounted: undefined|Function\n    )\n    {\n        // Set instance variables.\n        this.ref = ref;\n        this.el = el;\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.created = created;\n        this.beforeMount = beforeMount;\n        this.mounted = mounted;\n\n        // Once the instance is created, run the created hook if it exists.\n        if (this.created !== undefined) {\n            this.created();\n        }\n    }\n\n    /**\n     * Method to mount the form instance.\n     * @return {void}\n     */\n    mount(): void\n    {\n        // Create a new form instance.\n        const form = new Form(this.form, this.onsubmit, this.el);\n\n        // Run before mounted hook if it exists.\n        if (this.beforeMount !== undefined) {\n            this.beforeMount();\n        }\n\n        // If we have a form object then we will need to build the form.\n        if (typeof this.form === 'object') {\n            form.create().then(() => {\n                // Once the form is made, we need to create the internal\n                // elements...\n                form.createInternalElements(this.form['id']).then(() => {\n                    // Then we need to bind events to the form...\n                    form.bind().then(() => {\n                        // Run mounted hook if that exists.\n                        if (this.mounted !== undefined) {\n                            this.mounted();\n                        }\n                    })\n                });\n            });\n        }\n        // Else, if the form is already in the DOM, we just need to bind the\n        // onsubmit event to it.\n        else {\n            // Then we need to bind events to the form...\n            form.bind().then(() => {\n                if (this.mounted !== undefined) {\n                    this.mounted();\n                }\n            })\n        }\n    }\n\n    /**\n     * Method to destroy the instance.\n     * @return {void}\n     */\n    destroy(): void\n    {\n        // Remove from DOM.\n        this.unmount();\n        // Remove instance reference.\n        window.__FORMJS__.instances = window.__FORMJS__.instances.filter(current => current !== this);\n    }\n\n    /**\n     * Method to get a value of a chosen input by ID.\n     * @param {string} elementId - element id.\n     * @return {string}\n     */\n    getInputValue(elementId: string): string {\n        // If the element was already present in the DOM when we created the instance\n        // then we won't have a record of it. Throw an error here.\n        if (typeof this.form !== 'object') {\n            throw window.__FORMJS__.error(`Trying to get input value of an element that doesn't exist on the instance \\`${this.ref}\\`.`)\n        }\n\n        // Else, filter elements to check that it exists. Then return.\n        const elements = this.form.elements.filter((element: FormObjectElements) => element.attributes.id === elementId);\n\n        // If there is no element on the instance with that ID, throw an error.\n        if (elements.length === 0) {\n            throw window.__FORMJS__.error(`Trying to get input value of an element that doesn't exist on the instance \\`${this.ref}\\`.`)\n        }\n\n        return document.getElementById(elementId).value;\n    }\n}\n","import { Library } from './lib/library';\nimport { Options } from './lib/options';\nimport { Instance } from './lib/instance';\nimport { Validator } from './lib/validator';\n\n/**\n * FormJS library entry point.\n */\nexport class FormJS\n{\n    options: FormJSOptions;\n    instances: Array<Instance> = [];\n\n    // One line methods...\n    validate: object = (el: string, rules: string) => new Validator().test({ el: el, rules: rules });\n    version = (): string => Library.version;\n    getInstances = (): Array<Instance> => [...this.instances];\n    error = (error: string): void => console.error(`[${Library.name.toUpperCase()} ERROR] ${error}`);\n\n    /**\n     * Constructor to initialise the form instance.\n     * @param {Options} options - FormJS options.\n     * @return {Instance}\n     */\n    create = (options: FormJSOptions): Instance|Error =>\n    {\n        // Let's start creating the form...\n        try {\n            // Test options are as they need to be via the `Test` class.\n            Options.test(options, this.instances);\n\n            // Init a new instance.\n            const instance = new Instance(\n                options.ref,\n                options.el,\n                options.form,\n                options.onsubmit,\n                options.created,\n                options.beforeMount,\n                options.mounted\n            );\n\n            // Let's set our options so they're accessible in other API functions.\n            this.options = options;\n\n            // Lets push the created instance to the instances array so it can be\n            // accessed and modified.\n            this.instances.push(instance);\n\n            // Set global variable. This is used within the library.\n            window.__FORMJS__ = this;\n\n            // Return instance.\n            return instance;\n        }\n        /**\n         * Error handling is done here for anything that went wrong above...\n         * @param {string} e\n         */\n        catch(e) {\n            this.error(e);\n        }\n    }\n}\n"],"names":["Library","name","version","RootOptionsStructure","requiredOptions","type","option","acceptedTypes","optional","type2","ElementOptionsStructure","Options","test","options","instances","testExistsAndTypes","ref","testIsUniqueInInstances","el","form","elements","length","forEach","element","context","payload","filter","instance","requiredOption","hasOwnProperty","JSON","stringify","typesCorrect","some","formData","validationsToMake","constructor","sortValidations","push","criteria","rules","result","passed","failed","validation","allCriteria","split","includes","testMinLength","testMaxLength","testIsEmail","testIsDisposableEmail","then","response","testHasNumber","testHasSymbol","testHasCapital","testRequired","Promise","resolve","reject","attributes","id","validate","criteriaValue","parseInt","document","getElementById","value","charAt","toUpperCase","slice","fetch","json","data","disposable","fetchApiParams","onsubmit","wrappingEl","create","createElement","setAttribute","appendChild","createInternalElements","rootElement","elementName","formElement","innerHTML","text","key","Object","entries","bind","addEventListener","e","submit","blacklistedKeys","containsBlacklistedKey","blacklistedKey","preventDefault","before","includeFormData","fromEntries","FormData","target","url","method","body","success","catch","error","Validator","created","beforeMount","mounted","getAllElements","children","unmount","remove","mount","Form","destroy","__FORMJS__","window","current","getInputValue","elementId","getInstances","console","Instance"],"mappings":"yEAGaA,CAAAA,QAAU,CACnBC,KAAM,QADa,CAEnBC,QAAS,QAFU,EAeVC,qBAAuB,CAChCC,gBAAgBC,EAAoB,KAAM,OAE/B,CACH,CACIC,OAAQ,KADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CADG,CAKH,CACID,OAAQ,IADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CAGIC,WAHJ,CALG,CAUH,CACIF,OAAQ,MADZ,CAEIC,cAAe,CAAC,QAAD,CAAW,QAAX,CAFnB,CAIIH,gBAAgBK,EAAoB,KAAO,OAEtB,QAAT,GAAAA,EAAqB,GAAK,CAC9B,CACIH,OAAQ,IADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CAD8B,CAK9B,CACID,OAAQ,UADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CAL8B,EAN1C,CAVG,CA4BH,CACID,OAAQ,UADZ,CAEIC,cAAe,CAAC,QAAD,CAAW,UAAX,CAFnB,CAIIH,gBAAgBK,EAAoB,KAAO,OAEhC,CACH,CACIH,OAAQ,QADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CADG,CAKH,CACID,OAAQ,KADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CALG,CASH,CACID,OAAQ,iBADZ,CAEIC,cAAe,CAAC,SAAD,CAFnB,CAGIC,WAHJ,CATG,CAcH,CACIF,OAAQ,QADZ,CAEIC,cAAe,CAAC,UAAD,CAAa,UAAb,CAFnB,CAGIC,WAHJ,CAdG,CAmBH,CACIF,OAAQ,SADZ,CAEIC,cAAe,CAAC,UAAD,CAAa,UAAb,CAFnB,CAGIC,WAHJ,CAnBG,CAwBH,CACIF,OAAQ,OADZ,CAEIC,cAAe,CAAC,UAAD,CAAa,UAAb,CAFnB,CAGIC,WAHJ,CAxBG,EANf,CA5BG,CAkEH,CACIF,OAAQ,SADZ,CAEIC,cAAe,CAAC,UAAD,CAAa,UAAb,CAFnB,CAGIC,WAHJ,CAlEG,CAuEH,CACIF,OAAQ,aADZ,CAEIC,cAAe,CAAC,UAAD,CAAa,UAAb,CAFnB,CAGIC,WAHJ,CAvEG,CA4EH,CACIF,OAAQ,SADZ,CAEIC,cAAe,CAAC,UAAD,CAAa,UAAb,CAFnB,CAGIC,WAHJ,CA5EG,EAHqB,EAkGvBE,wBAA0B,CACnCN,gBAAgBC,EAAoB,KAAM,OAE/B,CACH,CACIC,OAAQ,IADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CADG,CAKH,CACID,OAAQ,UADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CAGIC,WAHJ,CALG,CAUH,CACIF,OAAQ,YADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CAIIH,gBAAgBK,EAAoB,KAAM,OAE/B,CACH,CACIH,OAAQ,IADZ,CAEIC,cAAe,CAAC,QAAD,CAFnB,CADG,EANf,CAVG,EAHwB,EC1G1BI,QAAU,CAMnBC,KAAKC,EAAwBC,EAC7B,MAESC,mBAAmBF,EAASV,qBAAqBC,eAArB,GAFrC,CAMwB,MAAhB,GAAAS,EAAQG,GANhB,OAOaC,wBAAwB,MAAOH,EAAWD,EAAQG,IAP/D,CAUuB,MAAf,GAAAH,EAAQK,EAVhB,OAWaD,wBAAwB,KAAMH,EAAWD,EAAQK,GAX9D,CAegC,QAAxB,QAAOL,CAAAA,EAAQM,IAfvB,MAiBaF,wBAAwB,OAAQH,EAAWD,EAAQM,KAjBhE,CAoB4C,CAA/B,CAAAN,EAAQM,IAAR,CAAaC,QAAb,CAAsBC,MApBnC,IAsBgBF,KAAKC,SAASE,QAASC,CAAD,EAAqB,MAC1CR,mBAAmBQ,EAASb,wBAAwBN,eAAxB,MA9B1B,CA8CnBa,wBAAwBO,EAAiBV,EAA0BW,EACnE,IAK6E,CAArE,CAAAX,EAAUY,MAAV,EAAiB,EAAYC,EAASH,EAAT,GAAsBC,CAAnD,EAA4DJ,eACnDrB,QAAQC,wBAAwBuB,UAAgBC,yBArD9C,CAoEnBV,mBAAmBF,EAAiBT,EAAgCoB,EAAuB,KAC3F,GAE2B,IAAZ,GAAAA,EAAuCX,EAAnBA,EAAQW,EAF3C,GAKoBF,QAASM,CAAD,EAA4B,IAG5C,CAACf,EAAQgB,cAAR,CAAuBD,QAAvB,CAAD,EAAoF,MAA/B,GAAAA,4BAEnCA,2BAA2CE,KAAKC,SAAL,CAAelB,CAAf,8BAAoDb,QAAQC,oBAIzH+B,CAAAA,wBAC4BC,KAAM5B,CAAD,EAAkB,IAI/C,MAAOQ,CAAAA,EAAQe,SAAf,GAA6CvB,CAA7C,EAAqD,CAACQ,EAAQgB,cAAR,CAAuBD,QAAvB,cAI/CI,IAMX,IAAAA,mBACkBJ,2BAA2CE,KAAKC,SAAL,CAAelB,CAAf,0BAAgDe,6BAA6C,MAAOf,CAAAA,EAAQe,wBAKzKA,EAAeC,cAAf,CAA8B,iBAA9B,CA9B4C,OAiCvCd,mBACDF,EACAe,iBAAA,CAAkC,MAAOf,CAAAA,EAAQe,SAAjD,EACAA,YA9GG,iBCNvB,CAEIT,KACAe,SACAC,kBAA8C,GAO9CC,YAAYjB,EAA+B,KAAMe,EAAwB,KACzE,MACSf,KAAOA,CADhB,MAESe,SAAWA,CAFpB,CAMsB,IAAd,QAAKf,IAAL,EAA2C,QAArB,QAAO,MAAKA,IAN1C,OAOakB,gBAAgB,KAAKlB,WAS5BP,CAAAA,KAAKC,EAAgC,KAC3C,CAIoB,IAAZ,GAAAA,CAJR,OAKasB,kBAAkBG,KAAK,CACxBf,QAASV,EAAQK,EADO,CAExBqB,SAAU1B,EAAQ2B,KAFM,EALpC,IAYQC,CAAAA,EAAc,CAAEC,SAAF,CAAgBC,OAAQ,EAAxB,2BAIUC,CAAAA,IAAc,MAAKT,kBAAmB,MAGxDU,CAAAA,EAAcD,EAAWL,QAAX,CAAoBO,KAApB,CAA0B,GAA1B,WAGTP,CAAAA,IAAYM,CAAAA,KACfN,EAASQ,QAAT,CAAkB,YAAlB,IACS,KAAKC,aAAL,CAAmBJ,EAAWrB,OAA9B,CAAuCgB,CAAvC,EAEJA,EAASQ,QAAT,CAAkB,YAAlB,IACI,KAAKE,aAAL,CAAmBL,EAAWrB,OAA9B,CAAuCgB,CAAvC,EAEJA,EAASQ,QAAT,CAAkB,SAAlB,IACI,KAAKG,WAAL,CAAiBN,EAAWrB,OAA5B,EAEJgB,EAASQ,QAAT,CAAkB,sBAAlB,OACC,MAAKI,qBAAL,CAA2BP,EAAWrB,OAAtC,EAA+C6B,IAA/C,EAAoD,EAAYX,EAASY,CAAzE,EAEDd,EAASQ,QAAT,CAAkB,WAAlB,IACI,KAAKO,aAAL,CAAmBV,EAAWrB,OAA9B,EAEJgB,EAASQ,QAAT,CAAkB,WAAlB,IACI,KAAKQ,aAAL,CAAmBX,EAAWrB,OAA9B,EAEJgB,EAASQ,QAAT,CAAkB,YAAlB,IACI,KAAKS,cAAL,CAAoBZ,EAAWrB,OAA/B,EAEJgB,EAASQ,QAAT,CAAkB,UAAlB,IACI,KAAKU,YAAL,CAAkBb,EAAWrB,OAA7B,IAKA,CACLmB,SADK,CAELC,4BAA6BJ,oBAFxB,EAQT,KAAAE,EAAOC,mCAOX,KAAAD,EAAOC,MAAP,CACJgB,QAAQC,OAAR,CAAgBlB,CAAhB,CADI,CAEJiB,QAAQE,MAAR,CAAenB,CAAf,EAUAJ,gBAAgBlB,EACxB,GAESC,SAASE,QAASC,CAAD,EAAiC,IAE9CA,EAAQM,cAAR,CAAuB,UAAvB,cAKAM,kBAAkBG,KAAK,CACxBf,QAASA,EAAQsC,UAAR,CAAmBC,EADJ,CAExBvB,SAAUhB,EAAQwC,QAFM,QAKxBxC,EAAQM,cAAR,CAAuB,UAAvB,QACKQ,gBAAgBd,MAazByB,cAAczB,EAAiBgB,EACvC,MAGUyB,CAAAA,EAAgBC,SAAS1B,EAASO,KAAT,CAAe,GAAf,EAAoB,CAApB,GAHnC,MAMQoB,CAAAA,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,KAAjC,CAAuC/C,MAAvC,CAAiD2C,CANzD,CAQe,CACHtB,SADG,CAEHC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,sBAAqCP,eAF/E,CARf,CAeW,CAAEtB,SAAF,CAAgBC,OAAQ,EAAxB,EASHM,cAAc1B,EAAiBgB,EACvC,MAGUyB,CAAAA,EAAgBC,SAAS1B,EAASO,KAAT,CAAe,GAAf,EAAoB,CAApB,GAHnC,MAMQoB,CAAAA,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,KAAjC,CAAuC/C,MAAvC,CAAiD2C,CANzD,CAQe,CACHtB,SADG,CAEHC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,0BAAyCP,eAFnF,CARf,CAeW,CAAEtB,SAAF,CAAgBC,OAAQ,EAAxB,EAQHO,YAAY3B,EACpB,MAEUyC,CAAAA,EAAgBE,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,MAF3D,MAKQ,qIAAgIxD,IAAhI,CAAqIoD,CAArI,CALR,CAOe,CACHtB,SADG,CAEHC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,0BAF1C,CAPf,CAcW,CAAE7B,SAAF,CAAgBC,OAAQ,EAAxB,OAQGQ,CAAAA,sBAAsB5B,EACpC,MAGUyC,CAAAA,EAAgBE,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,KAAjC,CAAuCtB,KAAvC,CAA6C,GAA7C,EAAkD,CAAlD,CAH1B,CAUUL,EAAS,KAAM+B,CAAAA,gDAAgDR,IAAhD,CAChBZ,IADgB,EACX,EAAYC,EAASoB,IAAT,EADD,EAEhBrB,IAFgB,EAEX,EACM,KAAAsB,EAAKC,UAAL,CACR,CACIjC,SADJ,CAEIC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,mCAFjD,CADQ,CAKR,CACI7B,SADJ,CAEIC,OAAQ,EAFZ,CARa,CAVzB,OAyBWe,CAAAA,QAAQC,OAAR,CAAgBlB,CAAhB,EAQHa,cAAc/B,EACtB,MAEUyC,CAAAA,EAAgBE,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,MAF3D,MAKQ,UAAKxD,IAAL,CAAUoD,CAAV,CALR,CAOe,CACHtB,SADG,CAEHC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,0BAF1C,CAPf,CAcW,CAAE7B,SAAF,CAAgBC,OAAQ,EAAxB,EAQHY,cAAchC,EACtB,MAEUyC,CAAAA,EAAgBE,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,MAF3D,MAKQ,+CAA0CxD,IAA1C,CAA+CoD,CAA/C,CALR,CAOe,CACHtB,SADG,CAEHC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,0BAF1C,CAPf,CAcW,CAAE7B,SAAF,CAAgBC,OAAQ,EAAxB,EAQHa,eAAejC,EACvB,MAEUyC,CAAAA,EAAgBE,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,MAF3D,MAKQ,aAAQxD,IAAR,CAAaoD,CAAb,CALR,CAOe,CACHtB,SADG,CAEHC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,kCAF1C,CAPf,CAcW,CAAE7B,SAAF,CAAgBC,OAAQ,EAAxB,EASHc,aAAalC,EACrB,MAEUyC,CAAAA,EAAgBE,SAASC,cAAT,CAAwB5C,CAAxB,EAAiC6C,MAF3D,MAKgC,EAAxB,EAAAJ,EAAc3C,MALtB,CAOe,CACHqB,SADG,CAEHC,UAAWpB,EAAQ8C,MAAR,CAAe,CAAf,EAAkBC,WAAlB,GAAkC/C,EAAQgD,KAAR,CAAc,CAAd,6CAF1C,CAPf,CAcW,CAAE7B,SAAF,CAAgBC,OAAQ,EAAxB,EAtUf,WCEA,CACIiC,eAAiB,GACjBzD,KACA0D,SACAC,WAQA1C,YAAYjB,EAAyB0D,EAA0BC,EAC/D,MACS3D,KAAOA,CADhB,MAES0D,SAAWA,CAFpB,MAGSC,WAAaA,EAOtBC,QACA,OAEW,IAAIrB,CAAAA,OAAJ,CAAY,CAACC,CAAD,CAAoBC,CAApB,GAAyC,IAE/B,QAArB,QAAO,MAAKzC,WACLyC,CAAAA,SAILzC,CAAAA,EAAO+C,SAASc,aAAT,CAAuB,MAAvB,WACRC,aAAa,KAAM,KAAK9D,IAAL,CAAU2C,aAGzBK,eAAe,KAAKW,YAAYI,YAAY/D,GAG9CwC,IAdJ,EAwBXwB,uBAAuBC,EACvB,OACW,IAAI1B,CAAAA,OAAJ,CAAY,CAACC,CAAD,CAAoBC,CAApB,GAEU,QAArB,QAAO,MAAKzC,IAFD,CAGJyC,GAHI,OAQVzC,KAAKC,SAASE,QAASC,CAAD,EAAiC,MAClD8D,CAAAA,EAAc9D,EAAQL,EAD4B,CAElDoE,EAAcpB,SAASc,aAAT,CAAuBK,CAAvB,CAFoC,IAKpD9D,EAAQM,cAAR,CAAuB,MAAvB,MACY0D,UAAYhE,EAAQiE,MAKhCjE,EAAQM,cAAR,CAAuB,YAAvB,WACW,CAAC4D,CAAD,CAAMrB,CAAN,GAAgBsB,CAAAA,OAAOC,OAAP,CAAepE,EAAQsC,UAAvB,IACXoB,aAAaQ,EAAKrB,YAK7BD,eAAeiB,GAAaF,YAAYI,EAlBO,CAsBpD/D,EAAQM,cAAR,CAAuB,UAAvB,CAtBoD,OAuB/CsD,uBAAuB5D,EAAQsC,UAAR,CAAmBC,KA/BxC,CAoCRH,GApCQ,CAAZ,EA4CXiC,MAA0B,OACf,IAAIlC,CAAAA,OAAJ,CAAY,IAAM,UAEZS,eAAqC,QAArB,QAAO,MAAKhD,IAAZ,CAAiC,KAAKA,IAAtC,CAA6C,KAAKA,IAAL,CAAU2C,IAAI+B,iBAAiB,SAAWC,CAAD,EAAY,KAAKC,MAAL,CAAYD,CAAZ,EAFtG,MAQfE,CAAAA,EAAkB,CAAC,QAAD,CAAW,KAAX,CAAkB,MAAlB,CAA0B,QAA1B,CAAoC,SAApC,CAA+C,OAA/C,SACjBL,QAAQ,KAAKd,UAAUvD,QAAQ,CAAC,CAACmE,CAAD,CAAKrB,CAAL,CAAD,GAAiB,IAE/C6B,CAAAA,OAIY3E,SAAQ,EAAkB,IAClC4E,GAAkBT,qBAPyB,CAkB/C,IAAAQ,CAlB+C,QAmB1CrB,eAAea,GAAOrB,CAnBoB,IATpD,EAwCX2B,OAAOD,EACP,GAEMK,gBAFN,CAKiC,MAAzB,QAAKtB,QAAL,CAAcuB,MALtB,OAMavB,SAASuB,QANtB,MAaUlE,CAAAA,EAAY,UAAK2C,QAAL,CAAcwB,eAAd,EAA4E,MAAlC,QAAKxB,QAAL,CAAcwB,eAAxD,CACdX,OAAOY,WAAP,CAAmB,GAAIC,CAAAA,QAAJ,CAAaT,EAAEU,MAAf,EAAuBb,OAAvB,EAAnB,CADc,CAEd,QAKC5B,SAAS7B,GAAUkB,KAAK,IAAM,OAGzB,KAAKyB,QAAL,CAAc4B,IAAK,CACrBC,OAAQ,KAAK7B,QAAL,CAAc6B,MADD,CAErBC,KAAM7E,KAAKC,SAAL,CAAeG,CAAf,CAFe,IAGlB,KAAK0C,cAHa,GAKtBxB,KAAMC,CAAD,EAAmB,IAEnB,KAAAA,UACMA,CAAAA,EAKoB,MAA1B,QAAKwB,QAAL,CAAc+B,OARK,OASd/B,SAAS+B,QAAQvD,KAE3BwD,MAAOC,CAAD,EAAmB,CAEI,MAAxB,QAAKjC,QAAL,CAAciC,KAFM,OAGfjC,SAASiC,MAAMA,EAAO,wBAW3C/C,SAAS7B,EACT,OAEW,IAAIwB,CAAAA,OAAJ,CAAY,MAAOC,CAAP,CAA0BC,CAA1B,GASc,QAArB,QAAO,MAAKzC,IAAZ,CACJwC,GADI,CAEJ,KAAM,IAAIoD,CAAAA,SAAJ,CAAc,KAAK5F,IAAnB,CAAyBe,CAAzB,EAAmCtB,IAAnC,GAEDwC,IAFC,CAEI,IAAMO,GAFV,EAIDkD,KAJC,EAIK,GAC2B,MAA1B,QAAKhC,QAAL,CAAciC,KAAd,EADD,OAEMjC,SAASiC,MAAMlG,EAAK+B,OAAQ,YAFlC,CAIIiB,EAAOhD,EAAK+B,OAJhB,CAJL,CAXP,EAlMf,eCAA,CAEI3B,IACAE,GACAC,KACA0D,SAGAmC,QACAC,YACAC,QAGAC,eAAiB,IAA4C,QAArB,QAAO,MAAKhG,IAAZ,CAAiC,CAAC,GAAG+C,SAASC,cAAT,CAAwB,KAAKhD,IAAL,CAAU2C,EAAlC,EAAsCsD,QAA1C,CAAjC,CAAuF,CAAC,GAAGlD,SAASC,cAAT,CAAwB,KAAKhD,IAA7B,EAAmCiG,QAAvC,EAC/HC,QAAU,IAAYnD,SAASC,cAAT,CAAwB,KAAKhD,IAAL,GAAxB,EAAyCmG,MAAzC,GAStBlF,YACIpB,EACAE,EACAC,EACA0D,EACAmC,EACAC,EACAC,EAEJ,MAESlG,IAAMA,CAFf,MAGSE,GAAKA,CAHd,MAISC,KAAOA,CAJhB,MAKS0D,SAAWA,CALpB,MAMSmC,QAAUA,CANnB,MAOSC,YAAcA,CAPvB,MAQSC,QAAUA,CARnB,CAWyB,MAAjB,QAAKF,OAXb,OAYaA,UAQbO,OACA,MAEUpG,CAAAA,EAAO,GAAIqG,CAAAA,IAAJ,CAAS,KAAKrG,IAAd,CAAoB,KAAK0D,QAAzB,CAAmC,KAAK3D,EAAxC,EAGY,MAArB,QAAK+F,WALb,OAMaA,aANb,CAU6B,QAArB,QAAO,MAAK9F,IAVpB,GAWa4D,SAAS3B,KAAK,IAAM,GAGhB+B,uBAAuB,KAAKhE,IAAL,KAAiBiC,KAAK,IAAM,GAE/CwC,OAAOxC,KAAK,IAAM,CAEE,MAAjB,QAAK8D,OAFU,OAGVA,eAnB7B,GA6BatB,OAAOxC,KAAK,IAAM,CACE,MAAjB,QAAK8D,OADU,OAEVA,YAUrBO,SACA,MAESJ,SAFT,QAIWK,WAAW5G,UAAY6G,OAAOD,UAAP,CAAkB5G,SAAlB,CAA4BY,MAA5B,EAAmC,EAAWkG,IAAY,IAA1D,EAQlCC,cAAcC,EAA2B,IAGZ,QAArB,QAAO,MAAK3G,UACNwG,CAAAA,OAAOD,UAAP,CAAkBZ,KAAlB,iFAAwG,KAAK9F,QAA7G,OAIJI,CAAAA,EAAW,KAAKD,IAAL,CAAUC,QAAV,CAAmBM,MAAnB,CAA2BH,CAAD,EAAiCA,EAAQsC,UAAR,CAAmBC,EAAnB,GAA0BgE,CAArF,KAGO,CAApB,GAAA1G,EAASC,YACHsG,CAAAA,OAAOD,UAAP,CAAkBZ,KAAlB,iFAAwG,KAAK9F,QAA7G,QAGHkD,CAAAA,SAASC,cAAT,CAAwB2D,CAAxB,EAAmC1D,MA1HlD,aCGA,CACIvD,QACAC,UAA6B,GAG7BiD,SAAmB,CAAC7C,CAAD,CAAasB,CAAb,GAA+B,GAAIuE,CAAAA,SAAJ,GAAgBnG,IAAhB,CAAqB,CAAEM,GAAAA,CAAF,CAAUsB,MAAAA,CAAV,CAArB,EAClDtC,QAAU,IAAcF,QAAQE,QAChC6H,aAAe,IAAuB,CAAC,GAAG,KAAKjH,SAAT,EACtCgG,MAASA,CAAD,EAAyBkB,QAAQlB,KAAR,KAAkB9G,QAAQC,IAAR,CAAaqE,WAAb,aAAqCwC,GAAvD,EAOjC/B,OAAUlE,CAAD,EACT,IAEQ,SAEQD,KAAKC,EAAS,KAAKC,UAF3B,MAKMa,CAAAA,EAAW,GAAIsG,CAAAA,QAAJ,CACbpH,EAAQG,GADK,CAEbH,EAAQK,EAFK,CAGbL,EAAQM,IAHK,CAIbN,EAAQgE,QAJK,CAKbhE,EAAQmG,OALK,CAMbnG,EAAQoG,WANK,CAObpG,EAAQqG,OAPK,cAWZrG,QAAUA,OAIVC,UAAUwB,KAAKX,UAGb+F,WAAa,KAGb/F,QAMLmE,EAAN,MACSgB,MAAMhB,IAnDvB"}