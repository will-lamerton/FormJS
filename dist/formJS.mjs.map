{"version":3,"file":"formJS.mjs","sources":["../src/lib/library.ts","../src/lib/options.ts","../src/lib/validator.ts","../src/lib/form.ts","../src/lib/instance.ts","../src/index.ts"],"sourcesContent":["/**\n * FormJS library options.\n */\nexport const Library = {\n    name: 'FormJS',\n    version: '1.0.10',\n}\n\n/**\n * FormJS options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const RootOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'ref',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'form',\n                acceptedTypes: ['object', 'string'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return (type === 'string') ? [] : [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'elements',\n                            acceptedTypes: ['object']\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'onsubmit',\n                acceptedTypes: ['object', 'Function'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return [\n                        {\n                            option: 'method',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'url',\n                            acceptedTypes: ['string']\n                        },\n                        {\n                            option: 'includeFormData',\n                            acceptedTypes: ['boolean'],\n                            optional: true,\n                        },\n                        {\n                            option: 'before',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'success',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'error',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'created',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'beforeMount',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'mounted',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            }\n        ];\n    }\n}\n\n/**\n * FormJS Element Options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const ElementOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'validate',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'attributes',\n                acceptedTypes: ['object'],\n\n                requiredOptions(type: null|string = null) {\n                    type;\n                    return [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        }\n                    ]\n                }\n            }\n        ]\n    }\n}\n","import { Library } from './library';\nimport { RootOptionsStructure } from './library';\nimport { ElementOptionsStructure } from './library';\n\n/**\n * A set of options testing functions for the library.\n *\n * These exist for more efficient and useful error reporting and library\n * stability.\n */\nexport const Options = {\n    /**\n     * Method to test all required options against all criteria.\n     * @param {object} options - options object to test with.\n     * @param {Array<object>} - current FormJS instances to test against.\n     */\n    test(options: object, instances: Array<object>)\n    {\n        // Test options exist and correct types on root options...\n        this.testExistsAndTypes(options, RootOptionsStructure.requiredOptions());\n\n        // Test `ref` and `el` are unique across all instances as long as they're\n        // not `undefined`.\n        if (options['ref'] !== undefined) {\n            this.testIsUniqueInInstances('ref', instances, options['ref']);\n        }\n\n        if (options['el'] !== undefined) {\n            this.testIsUniqueInInstances('el', instances, options['el']);\n        }\n\n        // If form is a string...\n        if (typeof options['form'] === 'string') {\n            // Test that the form is unique across all instances.\n            this.testIsUniqueInInstances('form', instances, options['form']);\n        }\n        // Else if an object with `elements` array longer than 0.\n        else if (options['form']['elements'].length > 0) {\n            // Loop these elements and test options and correct types in them.\n            options['form']['elements'].forEach((element: object) => {\n                this.testExistsAndTypes(element, ElementOptionsStructure.requiredOptions());\n            });\n        }\n    },\n\n    /**\n     * Method to test if an option is unique in the library instances. This\n     * is a useful because we don't always want repeating vital options. For\n     * example, the same form being bound to twice.\n     *\n     * @param {string} context - context in regards to nesting in the options object.\n     * @param {Array<object>} instances - the current FormJS instances.\n     * @param {any} payload - option to test exists in context.\n     * @return {void}\n     * @throws {Error}\n     */\n    testIsUniqueInInstances(context: string, instances: Array<object>, payload: any): void\n    {\n        // Filter array by picking out matching payloads. If this new array has\n        // a length greater than 1... then we have a match where we shouldn't.\n        //\n        // Throw an error in this case.\n        if (instances.filter(instance => instance[context] === payload).length > 0) {\n            throw `${Library.name} instance with \\`${context}\\`, \\`${payload}\\` is already in use.`;\n        }\n    },\n\n    /**\n     * Method to test the options passed against the structure the library\n     * expects.\n     *\n     * @param {object} options - options passed by user.\n     * @param {Array<object>} - requiredOptions - options structure that is required\n     * by FormJS.\n     * @param {null|string} context - optional context for options to specify nesting.\n     * @return {void}\n     * @throws {Error}\n     */\n    testExistsAndTypes(options: object, requiredOptions: Array<object>, context: null|string = null): void\n    {\n        // Check if we have a context and apply that immediately if so.\n        options = (context !== null) ? options[context] : options;\n\n        // Loop through our required options structure...\n        requiredOptions.forEach((requiredOption: object) => {\n            // First we'll check each required option is in the users options\n            // *unless* it's optional...\n            if (!options.hasOwnProperty(requiredOption['option']) && requiredOption['optional'] === undefined) {\n                // Throwing an error if not present and not optional...\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` required to create new ${Library.name} instance.`;\n            }\n\n            // Then, we'll loop through our accepted types...\n            let typesCorrect = false;\n            requiredOption['acceptedTypes'].some((type: string) => {\n                // ...Checking to see if each one matches the passed type *or*\n                // the passed option doesn't exist in case we're testing an option\n                // that's optional and could not be present.\n                if (typeof options[requiredOption['option']] === type || !options.hasOwnProperty(requiredOption['option'])) {\n                    // Exit out of loop if a type match has been made or\n                    // we're skipping. This signifies the option has passed.\n                    typesCorrect = true;\n                    return typesCorrect;\n                }\n            });\n\n            // After looping, we'll check if any types are incorrect throwing\n            // an error if they are.\n            if (typesCorrect === false) {\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` requires type(s) \\`${requiredOption['acceptedTypes']}\\`. Type \\`${typeof options[requiredOption['option']]}\\` received.`;\n            }\n\n            // Lastly, we'll test for nested required options inside the\n            // current required options.\n            if (requiredOption.hasOwnProperty('requiredOptions')) {\n                // If they exist, re-run this method with updated context and\n                // required options.\n                this.testExistsAndTypes(\n                    options,\n                    requiredOption['requiredOptions'](typeof options[requiredOption['option']]),\n                    requiredOption['option']\n                );\n            }\n\n            // Once here, we're done testing the current context, return.\n            return;\n        });\n    },\n}\n","/**\n * Class to validate form entries.\n */\nexport class Validator\n{\n    // Class variables.\n    form: null|object|string;\n    formData: null|object;\n    validationsToMake: Array<object> = [];\n\n    /**\n     * Constructor\n     * @param {object} form - form object.\n     * @param {object} formData - form data object.\n     */\n    constructor(form: null|object|string = null, formData: null|object = null)\n    {\n        this.form = form;\n        this.formData = formData;\n\n        // If we have a form object, then we need to gather the form\n        // validations required into an array to action.\n        if (form !== null) {\n            this.sortValidations(this.form);\n        }\n    }\n\n    /**\n     * Method to run validation tests.\n     * @param {null|object} options - options { el: string, rules: string }\n     * @return {object}\n     */\n    async test(options: null|object = null): Promise<any>\n    {\n        // Sometimes the validation class will be used for ad-hoc validations\n        // by passing an object. If one isn't passed though, we'll assume we're\n        // testing all validations across a whole form...\n        if (options !== null) {\n            this.validationsToMake.push({\n                element: options['el'],\n                criteria: options['rules'],\n            });\n        }\n\n        // Setting result structure up.\n        let result: any = { passed: true, failed: '' };\n\n        // Create a new labelled `for` loop that then loops through every\n        // validation to make.\n        validationLayer: for (const validation of this.validationsToMake) {\n            // Split validations down into an array of criteria.\n            // Each criteria is seperated by `|`.\n            const allCriteria = validation['criteria'].split('|');\n\n            // Then, loop through each criteria and match it to a test.\n            for (const criteria of allCriteria) {\n                if (criteria.includes('minLength:')) {\n                    result = this.testMinLength(validation['element'], criteria)\n                }\n                else if (criteria.includes('maxLength:')) {\n                    result = this.testMaxLength(validation['element'], criteria);\n                }\n                else if (criteria.includes('isEmail')) {\n                    result = this.testIsEmail(validation['element']);\n                }\n                else if (criteria.includes('isNotDisposableEmail')) {\n                    await this.testIsDisposableEmail(validation['element']).then(response => result = response);\n                }\n                else if (criteria.includes('hasNumber')) {\n                    result = this.testHasNumber(validation['element']);\n                }\n                else if (criteria.includes('hasSymbol')) {\n                    result = this.testHasSymbol(validation['element']);\n                }\n                else if (criteria.includes('hasCapital')) {\n                    result = this.testHasCapital(validation['element']);\n                }\n                else if (criteria.includes('required')) {\n                    result = this.testRequired(validation['element']);\n                }\n\n                // If no matching type, set result to an issue.\n                else {\n                    result = {\n                        passed: false,\n                        failed: `Validation rule \\`${criteria}\\` not recognised`\n                    };\n                }\n\n                // At the end of each loop, check to see if a test failed and if\n                // it did, break to the outer layer...\n                if (result['passed'] === false) {\n                    break validationLayer;\n                }\n            }\n        }\n\n        // Return promise based on outcome.\n        return (result.passed === true) ?\n            Promise.resolve(result) :\n            Promise.reject(result)\n        ;\n    }\n\n    /**\n     * Method to sort through the validations in the form object and create a\n     * list of them to action.\n     * @param {object|string} form - form object containing elements.\n     * @return {void}\n     */\n    private sortValidations(form: object|string): void\n    {\n        // Loop through passed form object.\n        form['elements'].forEach((element: object) => {\n            // If the element doesn't have property `validate`, return.\n            if (!element.hasOwnProperty('validate')) {\n                return;\n            }\n\n            // Push element id and validation criteria to the list to test.\n            this.validationsToMake.push({\n                element: element['attributes']['id'],\n                criteria: element['validate'],\n            });\n\n            if (element.hasOwnProperty('elements')) {\n                this.sortValidations(element);\n            }\n\n            return;\n        });\n    }\n\n    /**\n     * Method to test element value is at least X length.\n     * @param {string} element - element id.\n     * @param {string} criteria - testing criteria to get min length.\n     * @return {object}\n     */\n    private testMinLength(element: string, criteria: string): object\n    {\n        // Get min length by splitting criteria into an array by `:`. The second\n        // array value will be our min length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        if (document.getElementById(element)['value'].length  < criteriaValue) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be at least ${criteriaValue} characters!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test element value is not longer than X length.\n     * @param {string} element - element id.\n     * @param {string} criteria - testing criteria to get max length.\n     * @return {object}\n     */\n    private testMaxLength(element: string, criteria: string): object\n    {\n        // Get max length by splitting criteria into an array by `:`. The second\n        // array value will be our max length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        if (document.getElementById(element)['value'].length  > criteriaValue) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be no more than ${criteriaValue} characters!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value is an email.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testIsEmail(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Regex from: https://stackoverflow.com/questions/46155/whats-the-best-way-to-validate-an-email-address-in-javascript\n        if (/^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()\\.,;\\s@\\\"]+\\.{0,1})+([^<>()\\.,;:\\s@\\\"]{2,}|[\\d\\.]+))$/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be a valid email!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value is not a disposable email.\n     * @param {string} element - element id\n     * @return {Promise<object>}\n     */\n    private async testIsDisposableEmail(element: string): Promise<object>\n    {\n        // Get the element value and split it by `@` into an array. The second\n        // array element will be the domain to test.\n        const criteriaValue = document.getElementById(element)['value'].split('@')[1];\n\n        /**\n         * Then we'll call an API which will check an up to date disposable email\n         * database for the passed email domain.\n         * @/// <reference path=\"https://github.com/ivolo/disposable-email-domains\"/>\n         */\n        const result = await fetch(`https://open.kickbox.com/v1/disposable/${criteriaValue}`)\n            .then(response => response.json())\n            .then(data => {\n                return (data.disposable === true) ?\n                {\n                    passed: false,\n                    failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must not be a disposable email!`\n                } :\n                {\n                    passed: true,\n                    failed: ''\n                }\n            })\n        ;\n\n        return Promise.resolve(result);\n    }\n\n    /**\n     * Method to test that the element value has a number.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasNumber(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if element value contains a number.\n        if (/\\d/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a number!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value has a symbol.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasSymbol(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if the element value contains a symbol.\n        if (/[!@#$£%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]+/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a symbol!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value has a capital letter.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasCapital(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if element value has a capital letter.\n        if (/[A-Z]/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a capital letter!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test an element value has been entered as the passed element\n     * is required.\n     * @param {string} element - element id.\n     * @return {object}\n     */\n    private testRequired(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if element value length is 0.\n        if (criteriaValue.length <= 0) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} is required and can't be submitted empty!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n}\n","import { Validator } from './validator';\n\n/**\n * A set of functions that help with form processing.\n */\nexport class Form\n{\n    fetchApiParams = {};\n    form: string|FormObject;\n    onsubmit: OnsubmitObject;\n    wrappingEl: string;\n\n    /**\n     * Constructor\n     * @param {string|FormObject} form - form definition.\n     * @param {OnsubmitObject} onsubmit - onsubmit definition.\n     * @param {string} wrappingEl - wrapping element for form.\n     */\n    constructor(form: string|FormObject, onsubmit: OnsubmitObject, wrappingEl: string)\n    {\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.wrappingEl = wrappingEl;\n    }\n\n    /**\n     * Method to create a new form.\n     * @return {Promise<Function>}\n     */\n    create(): Promise<Function>\n    {\n        // Create a new promise...\n        return new Promise((resolve: Function, reject: Function) => {\n            // Reject if wrong type.\n            if (typeof this.form === 'string') {\n                return reject();\n            }\n\n            // Create a new form element and set the ID equal to the passed ID.\n            const form = document.createElement('form');\n            form.setAttribute('id', this.form.id);\n\n            // Append the form to the chosen `el` in the DOM structure.\n            document.getElementById(this.wrappingEl).appendChild(form);\n\n            // All created, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to create elements inside the newly created form!\n     * @param {Array<object>} elementsList - list of elements to create.\n     * @param {string} rootElement - element id to create new elements in.\n     * @return {Promise<Function>}\n     */\n    createInternalElements(rootElement: string): Promise<Function>\n    {\n        return new Promise((resolve: Function, reject: Function) => {\n            // If wrong type, reject.\n            if (typeof this.form === 'string') {\n                return reject();\n            }\n\n            // We'll loop through the elements specified and create new elements\n            // inside the form.\n            this.form.elements.forEach((element: FormObjectElements) => {\n                const elementName = element.el;\n                const formElement = document.createElement(elementName);\n\n                // If element has 'text' property, then we can set the innerHTML.\n                if (element.hasOwnProperty('text')) {\n                    formElement.innerHTML = element.text;\n                }\n\n                // We'll also loop through the attributes passed in each element and\n                // mount those too if they're present.\n                if (element.hasOwnProperty('attributes')) {\n                    for (const [key, value] of Object.entries(element.attributes)) {\n                        formElement.setAttribute(key, value);\n                    }\n                }\n\n                // Once we're done, we'll append the new element to the form.\n                document.getElementById(rootElement).appendChild(formElement);\n\n                // Lastly, let's check if there are any rooted elements to mount too.\n                // If there is, re-run this method.\n                if (element.hasOwnProperty('elements')) {\n                    this.createInternalElements(element.attributes.id);\n                }\n            });\n\n            // All done, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to bind the form to onsubmit event.\n     * @return {Promise<Function>}\n     */\n    bind(): Promise<Function> {\n        return new Promise(() => {\n            // Bind form...\n            document.getElementById((typeof this.form === 'string') ? this.form : this.form.id).addEventListener('submit', (e: any) => this.submit(e));\n\n            // Set up non-dynamic Fetch API params for submission.\n\n            // Here's a list of keys we *cannot* add to the params as they're\n            // reserved for FormJS workings.\n            const blacklistedKeys = ['method', 'url', 'body', 'before', 'success', 'error'];\n            Object.entries(this.onsubmit).forEach(([key,value]) => {\n                // Assume to begin with the key on loop is not blacklisted.\n                let containsBlacklistedKey = false;\n\n                // For every key on loop, loop through blakclisted keys and\n                // look for a match\n                blacklistedKeys.forEach(blacklistedKey => {\n                    if (blacklistedKey == key) {\n                        // Set `containsBlacklistedKey` equal to true and break\n                        // this loop.\n                        containsBlacklistedKey = true;\n                        return;\n                    }\n                });\n\n                // Check to see if the above loop found a match and if it didn't\n                // add the key=>value to the list of params to be used during\n                // submission.\n                if (containsBlacklistedKey === false) {\n                    this.fetchApiParams[key] = value;\n                }\n            });\n        });\n    }\n\n    /**\n     * Method to handle form submissions.\n     * @param {Event} e - event.\n     * @return {void}\n     * @throws {Error}\n     */\n    submit(e: any): void\n    {\n        // Prevent default.\n        e.preventDefault();\n\n        // Before we submit, if there's a a `before` method to run, run it.\n        if (this.onsubmit.before !== undefined) {\n            this.onsubmit.before();\n        }\n\n        // The user can choose to submit the form with or without form data.\n        //\n        // Determine whether or not we need to with the below statement and either\n        // set `formData` equal to the forms data *or* an empty object.\n        const formData = (this.onsubmit.includeFormData === true || this.onsubmit.includeFormData === undefined) ?\n            Object.fromEntries(new FormData(e.target).entries()) :\n            {}\n        ;\n\n        // If form passed as type object, then we could need to run validations\n        // too...\n        this.validate(formData).then(() => {\n            // Create a new Fetch API request with the URL & method from the onsubmit\n            // object and the JSON data from the form.\n            fetch(this.onsubmit.url, {\n                method: this.onsubmit.method,\n                body: JSON.stringify(formData),\n                ...this.fetchApiParams\n\n            }).then((response: any) => {\n                // If the response was not `ok`, catch the error.\n                if (response['ok'] === false) {\n                    throw response;\n                }\n\n                // If a `success` method exists on the onsubmit object, run it\n                // passing the response.\n                if (this.onsubmit.success !== undefined) {\n                    this.onsubmit.success(response);\n                }\n            }).catch((error: object) => {\n                // If an `error` method exists on the onsubmit object, run it.\n                if (this.onsubmit.error !== undefined) {\n                    this.onsubmit.error(error, 'request/response');\n                }\n            });\n        });\n    }\n\n    /**\n     * Method to validate form data against required validation.\n     * @param {object} formData - formData object.\n     * @return {Promise<Function>}\n     */\n    validate(formData: object): Promise<Function>\n    {\n        // Create a new promise to pass or fail validations...\n        return new Promise(async (resolve: Function, reject: Function) => {\n            // Check if our form was made by FormJS or by passing an ID.\n            // This will determine whether we validate or not.\n            //\n            // If made by user and passed as an ID, there won't be any\n            // validations to run at this time, so, resolve early.\n            //\n            // If there was an object, we'll create a new validator instance and\n            // run our tests...\n            return (typeof this.form === 'string') ?\n                resolve() :\n                await new Validator(this.form, formData).test()\n                    // Passed.\n                    .then(() => resolve())\n                    // Failed.\n                    .catch(test => {\n                        if (this.onsubmit.error() !== undefined) {\n                            this.onsubmit.error(test.failed, 'validator');\n                        }\n                        return reject(test.failed);\n                    })\n                ;\n            ;\n        });\n    }\n};\n","import { Form } from './form';\n\n/**\n * FormJS instance – every form = an instance.\n */\nexport class Instance\n{\n    // Class variables.\n    ref: string;\n    el: undefined|string;\n    form: string|FormObject;\n    onsubmit: OnsubmitObject;\n\n    // Lifecycle event hooks.\n    created: undefined|Function;\n    beforeMount: undefined|Function;\n    mounted: undefined|Function;\n\n    // One line methods...\n    getAllElements = (): Array<Element> => (typeof this.form === 'object') ? [...document.getElementById(this.form.id).children] : [...document.getElementById(this.form).children];\n    unmount = (): void => document.getElementById(this.form['id']).remove();\n\n    /**\n     * Constructor\n     * @param {string} ref - form instance reference.\n     * @param {undefined|string} el - element to attach the form to.\n     * @param {string|Form} form - form object containing what the form needs to look like.\n     * @param {OnsubmitObject} onsubmit - onsubmit object containing what needs to happen when the form is submitted.\n     */\n    constructor(\n        ref: string,\n        el: undefined|string,\n        form: string|FormObject,\n        onsubmit: OnsubmitObject,\n        created: undefined|Function,\n        beforeMount: undefined|Function,\n        mounted: undefined|Function\n    )\n    {\n        // Set instance variables.\n        this.ref = ref;\n        this.el = el;\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.created = created;\n        this.beforeMount = beforeMount;\n        this.mounted = mounted;\n\n        // Once the instance is created, run the created hook if it exists.\n        if (this.created !== undefined) {\n            this.created();\n        }\n    }\n\n    /**\n     * Method to mount the form instance.\n     * @return {void}\n     */\n    mount(): void\n    {\n        // Create a new form instance.\n        const form = new Form(this.form, this.onsubmit, this.el);\n\n        // Run before mounted hook if it exists.\n        if (this.beforeMount !== undefined) {\n            this.beforeMount();\n        }\n\n        // If we have a form object then we will need to build the form.\n        if (typeof this.form === 'object') {\n            form.create().then(() => {\n                // Once the form is made, we need to create the internal\n                // elements...\n                form.createInternalElements(this.form['id']).then(() => {\n                    // Then we need to bind events to the form...\n                    form.bind().then(() => {\n                        // Run mounted hook if that exists.\n                        if (this.mounted !== undefined) {\n                            this.mounted();\n                        }\n                    })\n                });\n            });\n        }\n        // Else, if the form is already in the DOM, we just need to bind the\n        // onsubmit event to it.\n        else {\n            // Then we need to bind events to the form...\n            form.bind().then(() => {\n                if (this.mounted !== undefined) {\n                    this.mounted();\n                }\n            })\n        }\n    }\n\n    /**\n     * Method to destroy the instance.\n     * @return {void}\n     */\n    destroy(): void\n    {\n        // Remove from DOM.\n        this.unmount();\n        // Remove instance reference.\n        window.__FORMJS__.instances = window.__FORMJS__.instances.filter(current => current !== this);\n    }\n\n    /**\n     * Method to get a value of a chosen input by ID.\n     * @param {string} elementId - element id.\n     * @return {string}\n     */\n    getInputValue(elementId: string): string {\n        // If the element was already present in the DOM when we created the instance\n        // then we won't have a record of it. Throw an error here.\n        if (typeof this.form !== 'object') {\n            throw window.__FORMJS__.error(`Trying to get input value of an element that doesn't exist on the instance \\`${this.ref}\\`.`)\n        }\n\n        // Else, filter elements to check that it exists. Then return.\n        const elements = this.form.elements.filter((element: FormObjectElements) => element.attributes.id === elementId);\n\n        // If there is no element on the instance with that ID, throw an error.\n        if (elements.length === 0) {\n            throw window.__FORMJS__.error(`Trying to get input value of an element that doesn't exist on the instance \\`${this.ref}\\`.`)\n        }\n\n        return document.getElementById(elementId)['value'];\n    }\n}\n","import { Library } from './lib/library';\nimport { Options } from './lib/options';\nimport { Instance } from './lib/instance';\nimport { Validator } from './lib/validator';\n\n/**\n * FormJS library entry point.\n */\nexport class FormJS\n{\n    options: FormJSOptions;\n    instances: Array<Instance> = [];\n\n    // One line methods...\n    validate: object = (el: string, rules: string) => new Validator().test({ el: el, rules: rules });\n    version = (): string => Library.version;\n    getInstances = (): Array<Instance> => [...this.instances];\n    error = (error: string): void => console.error(`[${Library.name.toUpperCase()} ERROR] ${error}`);\n\n    /**\n     * Constructor to initialise the form instance.\n     * @param {Options} options - FormJS options.\n     * @return {Instance}\n     */\n    create = (options: FormJSOptions): Instance|Error =>\n    {\n        // Let's start creating the form...\n        try {\n            // Test options are as they need to be via the `Test` class.\n            Options.test(options, this.instances);\n\n            // Init a new instance.\n            const instance = new Instance(\n                options.ref,\n                options.el,\n                options.form,\n                options.onsubmit,\n                options.created,\n                options.beforeMount,\n                options.mounted\n            );\n\n            // Let's set our options so they're accessible in other API functions.\n            this.options = options;\n\n            // Lets push the created instance to the instances array so it can be\n            // accessed and modified.\n            this.instances.push(instance);\n\n            // Set global variable. This is used within the library.\n            window.__FORMJS__ = this;\n\n            // Return instance.\n            return instance;\n        }\n        /**\n         * Error handling is done here for anything that went wrong above...\n         * @param {string} e\n         */\n        catch(e) {\n            this.error(e);\n        }\n    }\n}\n"],"names":["Library","name","version","RootOptionsStructure","requiredOptions","type","option","acceptedTypes","optional","type2","ElementOptionsStructure","Options","test","options","instances","testExistsAndTypes","testIsUniqueInInstances","length","forEach","element","context","payload","filter","instance","requiredOption","hasOwnProperty","JSON","stringify","typesCorrect","some","Validator","form","formData","validationsToMake","constructor","sortValidations","push","criteria","result","passed","failed","validationLayer","validation","allCriteria","split","includes","testMinLength","testMaxLength","testIsEmail","testIsDisposableEmail","then","response","testHasNumber","testHasSymbol","testHasCapital","testRequired","Promise","resolve","reject","criteriaValue","parseInt","document","getElementById","charAt","toUpperCase","slice","fetch","json","data","disposable","fetchApiParams","onsubmit","wrappingEl","create","createElement","setAttribute","id","appendChild","createInternalElements","rootElement","elements","elementName","el","formElement","innerHTML","text","key","value","Object","entries","attributes","bind","addEventListener","e","submit","blacklistedKeys","containsBlacklistedKey","blacklistedKey","preventDefault","before","includeFormData","fromEntries","FormData","target","validate","url","method","body","success","catch","error","Instance","ref","created","beforeMount","mounted","getAllElements","children","unmount","remove","mount","Form","destroy","window","__FORMJS__","current","getInputValue","elementId","FormJS","rules","getInstances","console"],"mappings":"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"}