{"version":3,"file":"formJS.mjs","sources":["../src/lib/library.ts","../src/lib/options.ts","../src/lib/validator.ts","../src/lib/form.ts","../src/lib/instance.ts","../src/index.ts"],"sourcesContent":["/**\n * FormJS library options.\n */\nexport const Library = {\n    name: 'FormJS',\n    version: '1.0.0',\n}\n\n/**\n * FormJS options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const RootOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'ref',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'form',\n                acceptedTypes: ['object', 'string'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return (type === 'string') ? [] : [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'elements',\n                            acceptedTypes: ['object']\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'onsubmit',\n                acceptedTypes: ['object', 'Function'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return [\n                        {\n                            option: 'type',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'url',\n                            acceptedTypes: ['string']\n                        },\n                        {\n                            option: 'before',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'success',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'error',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'created',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'beforeMount',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'mounted',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            }\n        ];\n    }\n}\n\n/**\n * FormJS Element Options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const ElementOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'validate',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'attributes',\n                acceptedTypes: ['object'],\n\n                requiredOptions(type: null|string = null) {\n                    type;\n                    return [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        }\n                    ]\n                }\n            }\n        ]\n    }\n}\n","import { Library } from './library';\nimport { RootOptionsStructure } from './library';\nimport { ElementOptionsStructure } from './library';\n\n/**\n * A set of options testing functions for the library.\n *\n * These exist for more efficient and useful error reporting and library\n * stability.\n */\nexport const Options = {\n    /**\n     * Method to test all required options against all criteria.\n     * @param {object} options - options object to test with.\n     * @param {Array<object>} - current FormJS instances to test against.\n     */\n    test(options: object, instances: Array<object>)\n    {\n        // Test options exist and correct types on root options...\n        this.testExistsAndTypes(options, RootOptionsStructure.requiredOptions());\n\n        // Test `ref` and `el` are unique across all instances as long as they're\n        // not `undefined`.\n        if (options['ref'] !== undefined) {\n            this.testIsUniqueInInstances('ref', instances, options['ref']);\n        }\n\n        if (options['el'] !== undefined) {\n            this.testIsUniqueInInstances('el', instances, options['el']);\n        }\n\n        // If form is a string...\n        if (typeof options['form'] === 'string') {\n            // Test that the form is unique across all instances.\n            this.testIsUniqueInInstances('form', instances, options['form']);\n        }\n        // Else if an object with `elements` array longer than 0.\n        else if (options['form']['elements'].length > 0) {\n            // Loop these elements and test options and correct types in them.\n            options['form']['elements'].forEach((element: object) => {\n                this.testExistsAndTypes(element, ElementOptionsStructure.requiredOptions());\n            });\n        }\n    },\n\n    /**\n     * Method to test if an option is unique in the library instances. This\n     * is a useful because we don't always want repeating vital options. For\n     * example, the same form being bound to twice.\n     *\n     * @param {string} context - context in regards to nesting in the options object.\n     * @param {Array<object>} instances - the current FormJS instances.\n     * @param {any} payload - option to test exists in context.\n     * @return {void}\n     * @throws {Error}\n     */\n    testIsUniqueInInstances(context: string, instances: Array<object>, payload: any): void\n    {\n        // Filter array by picking out matching payloads. If this new array has\n        // a length greater than 1... then we have a match where we shouldn't.\n        //\n        // Throw an error in this case.\n        if (instances.filter(instance => instance[context] === payload).length > 0) {\n            throw `${Library.name} instance with \\`${context}\\`, \\`${payload}\\` is already in use.`;\n        }\n    },\n\n    /**\n     * Method to test the options passed against the structure the library\n     * expects.\n     *\n     * @param {object} options - options passed by user.\n     * @param {Array<object>} - requiredOptions - options structure that is required\n     * by FormJS.\n     * @param {null|string} context - optional context for options to specify nesting.\n     * @return {void}\n     * @throws {Error}\n     */\n    testExistsAndTypes(options: object, requiredOptions: Array<object>, context: null|string = null): void\n    {\n        // Check if we have a context and apply that immediately if so.\n        options = (context !== null) ? options[context] : options;\n\n        // Loop through our required options structure...\n        requiredOptions.forEach((requiredOption: object) => {\n            // First we'll check each required option is in the users options\n            // *unless* it's optional...\n            if (!options.hasOwnProperty(requiredOption['option']) && requiredOption['optional'] === undefined) {\n                // Throwing an error if not present and not optional...\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` required to create new ${Library.name} instance.`;\n            }\n\n            // Then, we'll loop through our accepted types...\n            let typesCorrect = false;\n            requiredOption['acceptedTypes'].some((type: string) => {\n                // ...Checking to see if each one matches the passed type *or*\n                // the passed option doesn't exist in case we're testing an option\n                // that's optional and could not be present.\n                if (typeof options[requiredOption['option']] === type || !options.hasOwnProperty(requiredOption['option'])) {\n                    // Exit out of loop if a type match has been made or\n                    // we're skipping. This signifies the option has passed.\n                    typesCorrect = true;\n                    return typesCorrect;\n                }\n            });\n\n            // After looping, we'll check if any types are incorrect throwing\n            // an error if they are.\n            if (typesCorrect === false) {\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` requires type(s) \\`${requiredOption['acceptedTypes']}\\`. Type \\`${typeof options[requiredOption['option']]}\\` received.`;\n            }\n\n            // Lastly, we'll test for nested required options inside the\n            // current required options.\n            if (requiredOption.hasOwnProperty('requiredOptions')) {\n                // If they exist, re-run this method with updated context and\n                // required options.\n                this.testExistsAndTypes(\n                    options,\n                    requiredOption['requiredOptions'](typeof options[requiredOption['option']]),\n                    requiredOption['option']\n                );\n            }\n\n            // Once here, we're done testing the current context, return.\n            return;\n        });\n    },\n}\n","/**\n * Class to validate form entries.\n */\nexport class Validator\n{\n    // Class variables.\n    form: null|object|string;\n    formData: null|object;\n    validationsToMake: Array<object> = [];\n\n    /**\n     * Constructor\n     * @param {object} form - form object.\n     * @param {object} formData - form data object.\n     */\n    constructor(form: null|object|string = null, formData: null|object = null)\n    {\n        this.form = form;\n        this.formData = formData;\n\n        // If we have a form object, then we need to gather the form\n        // validations required into an array to action.\n        if (form !== null) {\n            this.sortValidations(this.form);\n        }\n    }\n\n    /**\n     * Method to run validation tests.\n     * @param {null|object} options - options { el: string, rules: string }\n     * @return {object}\n     */\n    async test(options: null|object = null): Promise<any>\n    {\n        // Sometimes the validation class will be used for ad-hoc validations\n        // by passing an object. If one isn't passed though, we'll assume we're\n        // testing all validations across a whole form...\n        if (options !== null) {\n            this.validationsToMake.push({\n                element: options['el'],\n                criteria: options['rules'],\n            });\n        }\n\n        // Setting result structure up.\n        let result: any = { passed: true, failed: '' };\n\n        // Create a new labelled `for` loop that then loops through every\n        // validation to make.\n        validationLayer: for (const validation of this.validationsToMake) {\n            // Split validations down into an array of criteria.\n            // Each criteria is seperated by `|`.\n            const allCriteria = validation['criteria'].split('|');\n\n            // Then, loop through each criteria and match it to a test.\n            for (const criteria of allCriteria) {\n                if (criteria.includes('minLength:')) {\n                    result = this.testMinLength(validation['element'], criteria)\n                }\n                else if (criteria.includes('maxLength:')) {\n                    result = this.testMaxLength(validation['element'], criteria);\n                }\n                else if (criteria.includes('isEmail')) {\n                    result = this.testIsEmail(validation['element']);\n                }\n                else if (criteria.includes('isNotDisposableEmail')) {\n                    await this.testIsDisposableEmail(validation['element']).then(response => result = response);\n                }\n                else if (criteria.includes('hasNumber')) {\n                    result = this.testHasNumber(validation['element']);\n                }\n                else if (criteria.includes('hasSymbol')) {\n                    result = this.testHasSymbol(validation['element']);\n                }\n                else if (criteria.includes('hasCapital')) {\n                    result = this.testHasCapital(validation['element']);\n                }\n                else if (criteria.includes('required')) {\n                    result = this.testRequired(validation['element']);\n                }\n\n                // If no matching type, set result to an issue.\n                else {\n                    result = {\n                        passed: false,\n                        failed: `Validation rule \\`${criteria}\\` not recognised`\n                    };\n                }\n\n                // At the end of each loop, check to see if a test failed and if\n                // it did, break to the outer layer...\n                if (result['passed'] === false) {\n                    break validationLayer;\n                }\n            }\n        }\n\n        // Return promise based on outcome.\n        return (result.passed === true) ?\n            Promise.resolve(result) :\n            Promise.reject(result)\n        ;\n    }\n\n    /**\n     * Method to sort through the validations in the form object and create a\n     * list of them to action.\n     * @param {object|string} form - form object containing elements.\n     * @return {void}\n     */\n    private sortValidations(form: object|string): void\n    {\n        // Loop through passed form object.\n        form['elements'].forEach((element: object) => {\n            // If the element doesn't have property `validate`, return.\n            if (!element.hasOwnProperty('validate')) {\n                return;\n            }\n\n            // Push element id and validation criteria to the list to test.\n            this.validationsToMake.push({\n                element: element['attributes']['id'],\n                criteria: element['validate'],\n            });\n\n            if (element.hasOwnProperty('elements')) {\n                this.sortValidations(element);\n            }\n\n            return;\n        });\n    }\n\n    /**\n     * Method to test element value is at least X length.\n     * @param {string} element - element id.\n     * @param {string} criteria - testing criteria to get min length.\n     * @return {object}\n     */\n    private testMinLength(element: string, criteria: string): object\n    {\n        // Get min length by splitting criteria into an array by `:`. The second\n        // array value will be our min length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        if (document.getElementById(element)['value'].length  < criteriaValue) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be at least ${criteriaValue} characters!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test element value is not longer than X length.\n     * @param {string} element - element id.\n     * @param {string} criteria - testing criteria to get max length.\n     * @return {object}\n     */\n    private testMaxLength(element: string, criteria: string): object\n    {\n        // Get max length by splitting criteria into an array by `:`. The second\n        // array value will be our max length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        if (document.getElementById(element)['value'].length  > criteriaValue) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be no more than ${criteriaValue} characters!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value is an email.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testIsEmail(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Regex from: https://stackoverflow.com/questions/46155/whats-the-best-way-to-validate-an-email-address-in-javascript\n        if (/^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()\\.,;\\s@\\\"]+\\.{0,1})+([^<>()\\.,;:\\s@\\\"]{2,}|[\\d\\.]+))$/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must be a valid email!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value is not a disposable email.\n     * @param {string} element - element id\n     * @return {Promise<object>}\n     */\n    private async testIsDisposableEmail(element: string): Promise<object>\n    {\n        // Get the element value and split it by `@` into an array. The second\n        // array element will be the domain to test.\n        const criteriaValue = document.getElementById(element)['value'].split('@')[1];\n\n        /**\n         * Then we'll call an API which will check an up to date disposable email\n         * database for the passed email domain.\n         * @/// <reference path=\"https://github.com/ivolo/disposable-email-domains\"/>\n         */\n        const result = await fetch(`https://open.kickbox.com/v1/disposable/${criteriaValue}`)\n            .then(response => response.json())\n            .then(data => {\n                return (data.disposable === true) ?\n                {\n                    passed: false,\n                    failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must not be a disposable email!`\n                } :\n                {\n                    passed: true,\n                    failed: ''\n                }\n            })\n        ;\n\n        return Promise.resolve(result);\n    }\n\n    /**\n     * Method to test that the element value has a number.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasNumber(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if element value contains a number.\n        if (/\\d/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a number!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value has a symbol.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasSymbol(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if the element value contains a symbol.\n        if (/[!@#$£%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]+/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a symbol!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test that the element value has a capital letter.\n     * @param {string} element - element id\n     * @return {object}\n     */\n    private testHasCapital(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if element value has a capital letter.\n        if (/[A-Z]/.test(criteriaValue) === false) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} must contain a capital letter!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n\n    /**\n     * Method to test an element value has been entered as the passed element\n     * is required.\n     * @param {string} element - element id.\n     * @return {object}\n     */\n    private testRequired(element: string): object\n    {\n        // Get element value...\n        const criteriaValue = document.getElementById(element)['value'];\n\n        // Test if element value length is 0.\n        if (criteriaValue.length <= 0) {\n            // Return failed validation.\n            return {\n                passed: false,\n                failed: `${element.charAt(0).toUpperCase() + element.slice(1)} is required and can't be submitted empty!`\n            };\n        }\n\n        // Else return passed validation.\n        return { passed: true, failed: '' };\n    }\n}\n","import { Validator } from './validator';\n\n/**\n * A set of functions that help with form processing.\n */\nexport class Form\n{\n    form: object|string;\n    onsubmit: object;\n    wrappingEl: string;\n\n    /**\n     * Constructor\n     * @param {object|string} form - form definition.\n     * @param {object} onsubmit - onsubmit definition.\n     * @param {string} wrappingEl - wrapping element for form.\n     */\n    constructor(form: object|string, onsubmit: object, wrappingEl: string)\n    {\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.wrappingEl = wrappingEl;\n    }\n\n    /**\n     * Method to create a new form.\n     * @return {Promise<Function>}\n     */\n    create(): Promise<Function>\n    {\n        // Create a new promise...\n        return new Promise((resolve: Function) => {\n            // Create a new form element and set the ID equal to the passed ID.\n            const form = document.createElement('form');\n            form.setAttribute('id', this.form['id']);\n\n            // Append the form to the chosen `el` in the DOM structure.\n            document.getElementById(this.wrappingEl).appendChild(form);\n\n            // All created, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to create elements inside the newly created form!\n     * @param {Array<object>} elementsList - list of elements to create.\n     * @param {string} rootElement - element id to create new elements in.\n     * @return {Promise<Function>}\n     */\n    createInternalElements(rootElement: string): Promise<Function>\n    {\n        return new Promise((resolve: Function) => {\n            // We'll loop through the elements specified and create new elements\n            // inside the form.\n            this.form['elements'].forEach((element: object) => {\n                const elementName = element['el'];\n                const formElement = document.createElement(elementName);\n\n                // If element has 'text' property, then we can set the innerHTML.\n                if (element.hasOwnProperty('text')) {\n                    formElement.innerHTML = element['text'];\n                }\n\n                // We'll also loop through the attributes passed in each element and\n                // mount those too if they're present.\n                if (element.hasOwnProperty('attributes')) {\n                    for (const [key, value] of Object.entries(element['attributes'])) {\n                        formElement.setAttribute(key, value);\n                    }\n                }\n\n                // Once we're done, we'll append the new element to the form.\n                document.getElementById(rootElement).appendChild(formElement);\n\n                // Lastly, let's check if there are any rooted elements to mount too.\n                // If there is, re-run this method.\n                if (element.hasOwnProperty('elements')) {\n                    this.createInternalElements(element['attributes']['id']);\n                }\n            });\n\n            // All done, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to bind the form to onsubmit event.\n     * @return {Promise<Function>}\n     */\n    bind(): Promise<Function> {\n        return new Promise(() => {\n             document.getElementById((typeof this.form === 'string') ? this.form : this.form['id']).addEventListener('submit', (e: any) => this.submit(e));\n        });\n    }\n\n    /**\n     * Method to handle form submissions.\n     * @param {Event} e - event.\n     * @return {void}\n     * @throws {Error}\n     */\n    submit(e: any): void\n    {\n        // Prevent default.\n        e.preventDefault();\n\n        // Before we submit, if there's a a `before` method to run, run it.\n        if (this.onsubmit['before'] !== undefined) {\n            this.onsubmit['before']();\n        }\n\n        // Get form data to submit with it.\n        const formData = Object.fromEntries(new FormData(e.target).entries());\n\n        // If form passed as type object, then we could need to run validations\n        // too...\n        this.validate(formData).then(() => {\n            // Create a new Fetch API request with the URL & method from the onsubmit\n            // object and the JSON data from the form.\n            fetch(this.onsubmit['url'], {\n                method: this.onsubmit['type'],\n                body: JSON.stringify(formData)\n            }).then((response: any) => {\n                // If the response was not `ok`, catch the error.\n                if (response['ok'] === false) {\n                    throw response;\n                }\n\n                // Parse the response body and if a `success` method exists on\n                // the onsubmit object, run it.\n                response.json().then((data: any) => (this.onsubmit['success'] !== undefined) ? this.onsubmit['success'](data) : false);\n            }).catch((error: object) => {\n                // If an `error` method exists on the onsubmit object, run it.\n                if (this.onsubmit['error'] !== undefined) {\n                    this.onsubmit['error'](error);\n                }\n            });\n        });\n    }\n\n    /**\n     * Method to validate form data against required validation.\n     * @param {object} formData - formData object.\n     * @return {Promise<Function>}\n     */\n    validate(formData: object): Promise<Function>\n    {\n        // Create a new promise to pass or fail validations...\n        return new Promise(async (resolve: Function, reject: Function) => {\n            // Check if our form was made by FormJS or by passing an ID.\n            // This will determine whether we validate or not.\n            //\n            // If made by user and passed as an ID, there won't be any\n            // validations to run at this time, so, resolve early.\n            //\n            // If there was an object, we'll create a new validator instance and\n            // run our tests...\n            return (typeof this.form === 'string') ?\n                resolve() :\n                await new Validator(this.form, formData).test()\n                    // Passed.\n                    .then(() => resolve())\n                    // Failed.\n                    .catch(test => {\n                        if (this.onsubmit['error'] !== undefined) {\n                            this.onsubmit['error'](test.failed, 'validator');\n                        }\n                        return reject(test.failed);\n                    })\n                ;\n            ;\n        });\n    }\n};\n","import { Form } from './form';\n\n/**\n * FormJS instance – every form = an instance.\n */\nexport class Instance\n{\n    // Class variables.\n    ref: string;\n    el: undefined|string;\n    form: string|object;\n    onsubmit: object;\n\n    // Lifecycle event hooks.\n    created: undefined|Function;\n    beforeMount: undefined|Function;\n    mounted: undefined|Function;\n\n    // One line methods...\n    getAllElements = (): Array<Element> => [...document.getElementById(this.form['id']).children];\n    unmount = (): void => document.getElementById(this.form['id']).remove();\n\n    /**\n     * Constructor\n     * @param {string} ref - form instance reference.\n     * @param {undefined|string} el - element to attach the form to.\n     * @param {string|object} form - form object containing what the form needs to look like.\n     * @param {object} onsubmit - onsubmit object containing what needs to happen when the form is submitted.\n     */\n    constructor(\n        ref: string,\n        el: undefined|string,\n        form: string|object,\n        onsubmit: object,\n        created: undefined|Function,\n        beforeMount: undefined|Function,\n        mounted: undefined|Function\n    )\n    {\n        // Set instance variables.\n        this.ref = ref;\n        this.el = el;\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.created = created;\n        this.beforeMount = beforeMount;\n        this.mounted = mounted;\n\n        // Once the instance is created, run the created hook if it exists.\n        if (this.created !== undefined) {\n            this.created();\n        }\n    }\n\n    /**\n     * Method to mount the form instance.\n     * @return {void}\n     */\n    mount(): void\n    {\n        // Create a new form instance.\n        const form = new Form(this.form, this.onsubmit, this.el);\n\n        // Run before mounted hook if it exists.\n        if (this.beforeMount !== undefined) {\n            this.beforeMount();\n        }\n\n        // If we have a form object then we will need to build the form.\n        if (typeof this.form === 'object') {\n            form.create().then(() => {\n                // Once the form is made, we need to create the internal\n                // elements...\n                form.createInternalElements(this.form['id']).then(() => {\n                    // Then we need to bind events to the form...\n                    form.bind().then(() => {\n                        // Run mounted hook if that exists.\n                        if (this.mounted !== undefined) {\n                            this.mounted();\n                        }\n                    })\n                });\n            });\n        }\n        // Else, if the form is already in the DOM, we just need to bind the\n        // onsubmit event to it.\n        else {\n            // Then we need to bind events to the form...\n            form.bind().then(() => {\n                if (this.mounted !== undefined) {\n                    this.mounted();\n                }\n            })\n        }\n    }\n\n    /**\n     * Method to destroy the instance.\n     * @return {void}\n     */\n    destroy(): void\n    {\n        // Remove from DOM.\n        this.unmount();\n        // Remove instance reference.\n        window.__FORMJS__.instances = window.__FORMJS__.instances.filter(current => current !== this);\n    }\n\n    /**\n     * Method to get a value of a chosen input by ID.\n     * @param {string} elementId - element id.\n     * @return {string}\n     */\n    getInputValue(elementId: string): string {\n        const elements = this.form['elements'].filter((element: object) => element['attributes']['id'] === elementId);\n\n        if (elements.length === 0) {\n            window.__FORMJS__.error(`Trying to get input value of an element that doesn't exist on the instance \\`${this.ref}\\`.`)\n        }\n\n        return document.getElementById(elementId)['value'];\n    }\n}\n","import { Library } from './lib/library';\nimport { Options } from './lib/options';\nimport { Instance } from './lib/instance';\nimport { Validator } from './lib/validator';\n\n/**\n * FormJS library entry point.\n */\nexport class FormJS\n{\n    options: object;\n    instances: Array<Instance> = [];\n\n    // One line methods...\n    validate: object = (el: string, rules: string) => new Validator().test({ el: el, rules: rules });\n    version = (): string => Library.version;\n    getInstances = (): Array<Instance> => [...this.instances];\n    error = (error: string): void => console.error(`[${Library.name.toUpperCase()} ERROR] ${error}`);\n\n    /**\n     * Constructor to initialise the form instance.\n     * @param {object} options - FormJS options.\n     * @return {Instance}\n     */\n    create = (options: object): Instance|Error =>\n    {\n        // Let's start creating the form...\n        try {\n            // Test options are as they need to be via the `Test` class.\n            Options.test(options, this.instances);\n\n            // Init a new instance.\n            const instance = new Instance(\n                options['ref'],\n                options['el'],\n                options['form'],\n                options['onsubmit'],\n                options['created'],\n                options['beforeMount'],\n                options['mounted']\n            );\n\n            // Let's set our options so they're accessible in other API functions.\n            this.options = options;\n\n            // Lets push the created instance to the instances array so it can be\n            // accessed and modified.\n            this.instances.push(instance);\n\n            // Set global variable. This is used within the library.\n            window.__FORMJS__ = this;\n\n            // Return instance.\n            return instance;\n        }\n        /**\n         * Error handling is done here for anything that went wrong above...\n         * @param {string} e\n         */\n        catch(e) {\n            this.error(e);\n        }\n    }\n}\n"],"names":["Library","name","version","RootOptionsStructure","requiredOptions","type","option","acceptedTypes","optional","type2","ElementOptionsStructure","Options","test","options","instances","testExistsAndTypes","testIsUniqueInInstances","length","forEach","element","context","payload","filter","instance","requiredOption","hasOwnProperty","JSON","stringify","typesCorrect","some","form","formData","validationsToMake","constructor","sortValidations","push","criteria","result","passed","failed","validation","allCriteria","split","includes","testMinLength","testMaxLength","testIsEmail","testIsDisposableEmail","then","response","testHasNumber","testHasSymbol","testHasCapital","testRequired","Promise","resolve","reject","criteriaValue","parseInt","document","getElementById","charAt","toUpperCase","slice","fetch","json","data","disposable","onsubmit","wrappingEl","create","createElement","setAttribute","appendChild","createInternalElements","rootElement","elementName","formElement","innerHTML","key","value","Object","entries","bind","addEventListener","e","submit","preventDefault","fromEntries","FormData","target","validate","method","body","catch","error","Validator","ref","el","created","beforeMount","mounted","getAllElements","children","unmount","remove","mount","Form","destroy","__FORMJS__","window","current","getInputValue","elementId","elements","rules","getInstances","console","Instance"],"mappings":"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"}