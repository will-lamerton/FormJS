{"version":3,"file":"formJS.mjs","sources":["../src/lib/library.ts","../src/lib/options.ts","../src/lib/validator.ts","../src/lib/form.ts","../src/lib/instance.ts","../src/index.ts"],"sourcesContent":["/**\n * FormJS library version.\n */\nexport const Version = '1.0.13';\n\n/**\n * FormJS options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const RootOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'ref',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'form',\n                acceptedTypes: ['object', 'string'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return (type === 'string') ? [] : [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'elements',\n                            acceptedTypes: ['object']\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'onsubmit',\n                acceptedTypes: ['object', 'Function'],\n\n                requiredOptions(type: null|string = null)  {\n                    type;\n                    return [\n                        {\n                            option: 'method',\n                            acceptedTypes: ['string'],\n                        },\n                        {\n                            option: 'url',\n                            acceptedTypes: ['string']\n                        },\n                        {\n                            option: 'includeFormData',\n                            acceptedTypes: ['boolean'],\n                            optional: true,\n                        },\n                        {\n                            option: 'before',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'success',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                        {\n                            option: 'error',\n                            acceptedTypes: ['function', 'Function'],\n                            optional: true,\n                        },\n                    ];\n                }\n            },\n            {\n                option: 'created',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'beforeMount',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            },\n            {\n                option: 'mounted',\n                acceptedTypes: ['function', 'Function'],\n                optional: true,\n            }\n        ];\n    }\n}\n\n/**\n * FormJS Element Options structure to test against.\n *\n * This object has an accessible `requiredOptions` method that returns the options\n * that must be passed in context with there accepted types and any other\n * nested required options.\n *\n * The `Test` object methods will traverse this object and test it's values.\n *\n */\nexport const ElementOptionsStructure = {\n    requiredOptions(type: null|string = null) {\n        type;\n        return [\n            {\n                option: 'el',\n                acceptedTypes: ['string'],\n            },\n            {\n                option: 'validate',\n                acceptedTypes: ['string'],\n                optional: true,\n            },\n            {\n                option: 'attributes',\n                acceptedTypes: ['object'],\n\n                requiredOptions(type: null|string = null) {\n                    type;\n                    return [\n                        {\n                            option: 'id',\n                            acceptedTypes: ['string'],\n                        }\n                    ]\n                }\n            }\n        ]\n    }\n}\n","import { RootOptionsStructure } from './library';\nimport { ElementOptionsStructure } from './library';\n\n/**\n * A set of options testing functions for the library.\n *\n * These exist for more efficient and useful error reporting and library\n * stability.\n */\nexport const Options = {\n    /**\n     * Method to test all required options against all criteria.\n     * @param {FormJSOptions} options - options object to test with.\n     * @param {Array<object>} - current FormJS instances to test against.\n     */\n    test(options: FormJSOptions, instances: Array<object>)\n    {\n        // Test options exist and correct types on root options...\n        this.testExistsAndTypes(options, RootOptionsStructure.requiredOptions());\n\n        // Test `ref` and `el` are unique across all instances as long as they're\n        // not `undefined`.\n        if (options.ref !== undefined) {\n            this.testIsUniqueInInstances('ref', instances, options.ref);\n        }\n\n        if (options.el !== undefined) {\n            this.testIsUniqueInInstances('el', instances, options.el);\n        }\n\n        // If form is a string...\n        if (typeof options.form === 'string') {\n            // Test that the form is unique across all instances.\n            this.testIsUniqueInInstances('form', instances, options.form);\n        }\n        // Else if an object with `elements` array longer than 0.\n        else if (options.form.elements.length > 0) {\n            // Loop these elements and test options and correct types in them.\n            options.form.elements.forEach((element: object) => {\n                this.testExistsAndTypes(element, ElementOptionsStructure.requiredOptions());\n            });\n        }\n    },\n\n    /**\n     * Method to test if an option is unique in the library instances. This\n     * is a useful because we don't always want repeating vital options. For\n     * example, the same form being bound to twice.\n     *\n     * @param {string} context - context in regards to nesting in the options object.\n     * @param {Array<object>} instances - the current FormJS instances.\n     * @param {any} payload - option to test exists in context.\n     * @return {void}\n     * @throws {Error}\n     */\n    testIsUniqueInInstances(context: string, instances: Array<object>, payload: any): void\n    {\n        // Filter array by picking out matching payloads. If this new array has\n        // a length greater than 1... then we have a match where we shouldn't.\n        //\n        // Throw an error in this case.\n        if (instances.filter(instance => instance[context] === payload).length > 0) {\n            throw `FormJS instance with \\`${context}\\`, \\`${payload}\\` is already in use.`;\n        }\n    },\n\n    /**\n     * Method to test the options passed against the structure the library\n     * expects.\n     *\n     * @param {object} options - options passed by user.\n     * @param {Array<object>} - requiredOptions - options structure that is required\n     * by FormJS.\n     * @param {null|string} context - optional context for options to specify nesting.\n     * @return {void}\n     * @throws {Error}\n     */\n    testExistsAndTypes(options: object, requiredOptions: Array<object>, context: null|string = null): void\n    {\n        // Check if we have a context and apply that immediately if so.\n        options = (context !== null) ? options[context] : options;\n\n        // Loop through our required options structure...\n        requiredOptions.forEach((requiredOption: object) => {\n            // First we'll check each required option is in the users options\n            // *unless* it's optional...\n            if (!options.hasOwnProperty(requiredOption['option']) && requiredOption['optional'] === undefined) {\n                // Throwing an error if not present and not optional...\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` required to create new FormJS instance.`;\n            }\n\n            // Then, we'll loop through our accepted types...\n            let typesCorrect = false;\n            requiredOption['acceptedTypes'].some((type: string) => {\n                // ...Checking to see if each one matches the passed type *or*\n                // the passed option doesn't exist in case we're testing an option\n                // that's optional and could not be present.\n                if (typeof options[requiredOption['option']] === type || !options.hasOwnProperty(requiredOption['option'])) {\n                    // Exit out of loop if a type match has been made or\n                    // we're skipping. This signifies the option has passed.\n                    typesCorrect = true;\n                    return typesCorrect;\n                }\n            });\n\n            // After looping, we'll check if any types are incorrect throwing\n            // an error if they are.\n            if (typesCorrect === false) {\n                throw `Option \\`${requiredOption['option']}\\` in context \\`${JSON.stringify(options)}\\` requires type(s) \\`${requiredOption['acceptedTypes']}\\`. Type \\`${typeof options[requiredOption['option']]}\\` received.`;\n            }\n\n            // Lastly, we'll test for nested required options inside the\n            // current required options.\n            if (requiredOption.hasOwnProperty('requiredOptions')) {\n                // If they exist, re-run this method with updated context and\n                // required options.\n                this.testExistsAndTypes(\n                    options,\n                    requiredOption['requiredOptions'](typeof options[requiredOption['option']]),\n                    requiredOption['option']\n                );\n            }\n\n            // Once here, we're done testing the current context, return.\n            return;\n        });\n    },\n}\n","/**\n * Class to validate form entries.\n */\nexport class Validator\n{\n    // Class variables.\n    form: null|FormObject|string;\n    formData: null|object;\n    validationsToMake: Array<ValidationsToMake> = [];\n    regexTests = [\n        {\n            // Regex from: https://stackoverflow.com/questions/46155/whats-the-best-way-to-validate-an-email-address-in-javascript\n            name: 'isEmail',\n            pattern: new RegExp(/^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()\\.,;\\s@\\\"]+\\.{0,1})+([^<>()\\.,;:\\s@\\\"]{2,}|[\\d\\.]+))$/),\n            errorMessage: 'Input must be a valid email!'\n        },\n        {\n            name: 'hasCapital',\n            pattern: new RegExp(/[A-Z]/),\n            errorMessage: 'Input must contain a capital letter!'\n        },\n        {\n            name: 'hasSymbol',\n            pattern: new RegExp(/[!@#$£%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]+/),\n            errorMessage: 'Input must contain a symbol!'\n        },\n        {\n            name: 'hasNumber',\n            pattern: new RegExp(/\\d/),\n            errorMessage: 'Input must contain a number!'\n        }\n    ];\n    passed = { passed: true, failed: '' };\n\n    /**\n     * Constructor\n     * @param {null|FormObject|string} form - form object.\n     * @param {null\\object} formData - form data object.\n     */\n    constructor(form: null|FormObject|string = null, formData: null|object = null)\n    {\n        this.form = form;\n        this.formData = formData;\n\n        // If we have a form object, then we need to gather the form\n        // validations required into an array to action.\n        if (this.form !== null && typeof this.form !== 'string') {\n            this.sortValidations(this.form);\n        }\n    }\n\n    /**\n     * Method to run validation tests.\n     * @param {null|AdHocValidation} options - options { el: string, rules: string }\n     * @return {Promise<Function>}\n     */\n    async test(options: null|AdHocValidation = null): Promise<Function>\n    {\n        // Sometimes the validation class will be used for ad-hoc validations\n        // by passing an object. If one isn't passed though, we'll assume we're\n        // testing all validations across a whole form...\n        if (options !== null) {\n            this.validationsToMake.push({\n                element: options.el,\n                criteria: options.rules,\n            });\n        }\n\n        // Setting result structure up.\n        let result: any = this.passed;\n\n        // Create a new labelled `for` loop that then loops through every\n        // validation to make.\n        validationLayer: for (const validation of this.validationsToMake) {\n            // Split validations down into an array of criteria.\n            // Each criteria is seperated by `|`.\n            const allCriteria = validation.criteria.split('|');\n\n            // Get value value to validate.\n            const value = document.getElementById(validation.element).value;\n\n            // Then, loop through each criteria and match it to a test.\n            for (const criteria of allCriteria) {\n                if (criteria.includes('minLength:')) {\n                    result = this.testMinLength(value, criteria)\n                }\n                else if (criteria.includes('maxLength:')) {\n                    result = this.testMaxLength(value, criteria);\n                }\n                else if (criteria.includes('isEmail')) {\n                    result = this.testRegex('isEmail', value);\n                }\n                else if (criteria.includes('isNotDisposableEmail')) {\n                    await this.testIsDisposableEmail(value).then(response => result = response);\n                }\n                else if (criteria.includes('hasNumber')) {\n                    result = this.testRegex('hasNumber', value);\n                }\n                else if (criteria.includes('hasSymbol')) {\n                    result = this.testRegex('hasSymbol', value);\n                }\n                else if (criteria.includes('hasCapital')) {\n                    result = this.testRegex('hasCapital', value);\n                }\n                else if (criteria.includes('required')) {\n                    result = this.testRequired(value);\n                }\n\n                // If no matching type, set result to an issue.\n                else {\n                    result = {\n                        passed: false,\n                        failed: `Validation rule \\`${criteria}\\` not recognised`\n                    };\n                }\n\n                // At the end of each loop, check to see if a test failed and if\n                // it did, break to the outer layer...\n                if (result.passed === false) {\n                    break validationLayer;\n                }\n            }\n        }\n\n        // Return promise based on outcome.\n        return (result.passed === true) ?\n            Promise.resolve(result) :\n            Promise.reject(result)\n        ;\n    }\n\n    /**\n     * Method to sort through the validations in the form object and create a\n     * list of them to action.\n     * @param {FormObject|FormObjectElements} form - form object containing elements.\n     * @return {void}\n     */\n    private sortValidations(form: any): void\n    {\n        // Loop through passed form object.\n        form.elements.forEach((element: FormObjectElements) => {\n            // If the element doesn't have property `validate`, return.\n            if (!element.hasOwnProperty('validate')) {\n                return;\n            }\n\n            // Push element id and validation criteria to the list to test.\n            this.validationsToMake.push({\n                element: element.attributes.id,\n                criteria: element.validate,\n            });\n\n            if (element.hasOwnProperty('elements')) {\n                this.sortValidations(element);\n            }\n        });\n    }\n\n    /**\n     * Method to test element value is at least X length.\n     * @param {string} value - element value.\n     * @param {string} criteria - testing criteria to get min length.\n     * @return {object}\n     */\n    private testMinLength(value: string, criteria: string): object\n    {\n        // Get min length by splitting criteria into an array by `:`. The second\n        // array value will be our min length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        return (value.length  < criteriaValue) ?\n            // Return failed validation.\n            {\n                passed: false,\n                failed: `Input must be at least ${criteriaValue} characters!`\n            } :\n            // Else return passed validation.\n            this.passed\n        ;\n    }\n\n    /**\n     * Method to test element value is not longer than X length.\n     * @param {string} value - element value.\n     * @param {string} criteria - testing criteria to get max length.\n     * @return {object}\n     */\n    private testMaxLength(value: string, criteria: string): object\n    {\n        // Get max length by splitting criteria into an array by `:`. The second\n        // array value will be our max length.\n        const criteriaValue = parseInt(criteria.split(':')[1]);\n\n        // If the element value length is less than the min length...\n        return (value.length  > criteriaValue) ?\n            // Return failed validation.\n            {\n                passed: false,\n                failed: `Input must be no more than ${criteriaValue} characters!`\n            } :\n            // Else return passed validation.\n            this.passed\n        ;\n    }\n\n    /**\n     * Method to test that the element value is not a disposable email.\n     * @param {string} value - element value\n     * @return {Promise<object>}\n     */\n    private async testIsDisposableEmail(value: string): Promise<object>\n    {\n        // Get the element value and split it by `@` into an array. The second\n        // array element will be the domain to test.\n        const criteriaValue = value.split('@')[1];\n\n        /**\n         * Then we'll call an API which will check an up to date disposable email\n         * database for the passed email domain.\n         * @/// <reference path=\"https://github.com/ivolo/disposable-email-domains\"/>\n         */\n        const result = await fetch(`https://open.kickbox.com/v1/disposable/${criteriaValue}`)\n            .then(response => response.json())\n            .then(data => {\n                return (data.disposable === true) ?\n                {\n                    passed: false,\n                    failed: `Input must not be a disposable email!`\n                } :\n                this.passed\n            })\n        ;\n\n        return Promise.resolve(result);\n    }\n\n    /**\n     * Method to test element value against a regex based on predefined patterns\n     * in class variable `regexTests`.\n     * @param {string} testName - name of test name\n     * @param {string} value - element value\n     * @return {object}\n     */\n    private testRegex(testName: string, value: string): object\n    {\n        // Get correct validation.\n        const validation = this.regexTests.filter(test => test.name === testName)[0];\n\n        // Test if element value against pattern.\n        return (new RegExp(validation.pattern).test(value) === false) ?\n            // Return failed validation.\n            {\n                passed: false,\n                failed: `${validation.errorMessage}`\n            } :\n            // Else return passed validation.\n            this.passed\n        ;\n    }\n\n    /**\n     * Method to test an element value has been entered as the passed element\n     * is required\n     * @param {string} value - element value.\n     * @return {object}\n     */\n    private testRequired(value: string): object\n    {\n        // Test if element value length is 0.\n        return (value.length <= 0) ?\n            // Return failed validation.\n            {\n                passed: false,\n                failed: `Input is required and can't be submitted empty!`\n            } :\n            // Else return passed validation.\n            this.passed\n        ;\n    }\n}\n","import { Validator } from './validator';\n\n/**\n * A set of functions that help with form processing.\n */\nexport class Form\n{\n    fetchApiParams = {};\n    form: string|FormObject;\n    onsubmit: OnsubmitObject;\n    wrappingEl: string;\n\n    /**\n     * Constructor\n     * @param {string|FormObject} form - form definition.\n     * @param {OnsubmitObject} onsubmit - onsubmit definition.\n     * @param {string} wrappingEl - wrapping element for form.\n     */\n    constructor(form: string|FormObject, onsubmit: OnsubmitObject, wrappingEl: string)\n    {\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.wrappingEl = wrappingEl;\n    }\n\n    /**\n     * Method to create a new form.\n     * @return {Promise<Function>}\n     */\n    create(): Promise<Function>\n    {\n        // Create a new promise...\n        return new Promise((resolve: Function, reject: Function) => {\n            // Reject if wrong type.\n            if (typeof this.form === 'string') {\n                return reject();\n            }\n\n            // Create a new form element and set the ID equal to the passed ID.\n            const form = document.createElement('form');\n            form.setAttribute('id', this.form.id);\n\n            // Append the form to the chosen `el` in the DOM structure.\n            document.getElementById(this.wrappingEl).appendChild(form);\n\n            // All created, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to create elements inside the newly created form!\n     * @param {Array<object>} elementsList - list of elements to create.\n     * @param {string} rootElement - element id to create new elements in.\n     * @return {Promise<Function>}\n     */\n    createInternalElements(rootElement: string): Promise<Function>\n    {\n        return new Promise((resolve: Function, reject: Function) => {\n            // If wrong type, reject.\n            if (typeof this.form === 'string') {\n                return reject();\n            }\n\n            // We'll loop through the elements specified and create new elements\n            // inside the form.\n            this.form.elements.forEach((element: FormObjectElements) => {\n                const formElement = document.createElement(element.el);\n\n                // If element has 'text' property, then we can set the innerHTML.\n                if (element.hasOwnProperty('text')) {\n                    formElement.innerHTML = element.text;\n                }\n\n                // We'll also loop through the attributes passed in each element and\n                // mount those too if they're present.\n                if (element.hasOwnProperty('attributes')) {\n                    for (const [key, value] of Object.entries(element.attributes)) {\n                        formElement.setAttribute(key, value);\n                    }\n                }\n\n                // Once we're done, we'll append the new element to the form.\n                document.getElementById(rootElement).appendChild(formElement);\n\n                // Lastly, let's check if there are any rooted elements to mount too.\n                // If there is, re-run this method.\n                if (element.hasOwnProperty('elements')) {\n                    this.createInternalElements(element.attributes.id);\n                }\n            });\n\n            // All done, so resolve.\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to bind the form to onsubmit event.\n     * @return {Promise<any>}\n     */\n    bind(): Promise<Function> {\n        return new Promise((resolve: Function) => {\n            // Bind form...\n            document.getElementById((typeof this.form === 'string') ? this.form : this.form.id).addEventListener('submit', (e: any) => this.submit(e));\n\n            // Set up non-dynamic Fetch API params for submission.\n\n            // Here's a list of keys we *cannot* add to the params as they're\n            // reserved for FormJS workings.\n            const blacklistedKeys = ['method', 'url', 'body', 'before', 'success', 'error'];\n            Object.entries(this.onsubmit).forEach(([key,value]) => {\n                // Assume to begin with the key on loop is not blacklisted.\n                let containsBlacklistedKey = false;\n\n                // For every key on loop, loop through blakclisted keys and\n                // look for a match\n                blacklistedKeys.forEach(blacklistedKey => {\n                    if (blacklistedKey == key) {\n                        // Set `containsBlacklistedKey` equal to true and break\n                        // this loop.\n                        containsBlacklistedKey = true;\n                        return;\n                    }\n                });\n\n                // Check to see if the above loop found a match and if it didn't\n                // add the key=>value to the list of params to be used during\n                // submission.\n                if (containsBlacklistedKey === false) {\n                    this.fetchApiParams[key] = value;\n                }\n            });\n\n            return resolve();\n        });\n    }\n\n    /**\n     * Method to handle form submissions.\n     * @param {Event} e - event.\n     * @return {void}\n     * @throws {Error}\n     */\n    submit(e: any): void\n    {\n        // Prevent default.\n        e.preventDefault();\n\n        // Before we submit, if there's a a `before` method to run, run it.\n        if (this.onsubmit.before !== undefined) {\n            this.onsubmit.before();\n        }\n\n        // The user can choose to submit the form with or without form data.\n        //\n        // Determine whether or not we need to with the below statement and either\n        // set `formData` equal to the forms data *or* an empty object.\n        const formData = (this.onsubmit.includeFormData === true || this.onsubmit.includeFormData === undefined) ?\n            Object.fromEntries(new FormData(e.target).entries()) :\n            {}\n        ;\n\n        // If form passed as type object, then we could need to run validations\n        // too...\n        this.validate(formData).then(() => {\n            // Create a new Fetch API request with the URL & method from the onsubmit\n            // object and the JSON data from the form.\n            fetch(this.onsubmit.url, {\n                method: this.onsubmit.method,\n                body: JSON.stringify(formData),\n                ...this.fetchApiParams\n\n            }).then((response: any) => {\n                // If the response was not `ok`, catch the error.\n                if (response['ok'] === false) {\n                    throw response;\n                }\n\n                // If a `success` method exists on the onsubmit object, run it\n                // passing the response.\n                if (this.onsubmit.success !== undefined) {\n                    this.onsubmit.success(response);\n                }\n            }).catch((error: object) => {\n                // If an `error` method exists on the onsubmit object, run it.\n                if (this.onsubmit.error !== undefined) {\n                    this.onsubmit.error({\n                        error: error,\n                        source: 'request/response'\n                    });\n                }\n            });\n        });\n    }\n\n    /**\n     * Method to validate form data against required validation.\n     * @param {object} formData - formData object.\n     * @return {Promise<Function>}\n     */\n    validate(formData: object): Promise<Function>\n    {\n        // Create a new promise to pass or fail validations...\n        return new Promise(async (resolve: Function, reject: Function) => {\n            // Check if our form was made by FormJS or by passing an ID.\n            // This will determine whether we validate or not.\n            //\n            // If made by user and passed as an ID, there won't be any\n            // validations to run at this time, so, resolve early.\n            //\n            // If there was an object, we'll create a new validator instance and\n            // run our tests...\n            return (typeof this.form === 'string') ?\n                resolve() :\n                await new Validator(this.form, formData).test()\n                    // Passed.\n                    .then(() => resolve())\n                    // Failed.\n                    .catch(test => {\n                        if (this.onsubmit.error !== undefined) {\n                            this.onsubmit.error({\n                                error: test.failed,\n                                source: 'validator'\n                            });\n                        }\n                        return reject(test.failed);\n                    })\n                ;\n            ;\n        });\n    }\n};\n","import { Form } from './form';\n\n/**\n * FormJS instance – every form = an instance.\n */\nexport class Instance\n{\n    // Class variables.\n    ref: string;\n    el: undefined|string;\n    form: string|FormObject;\n    onsubmit: OnsubmitObject;\n\n    // Lifecycle event hooks.\n    created: undefined|Function;\n    beforeMount: undefined|Function;\n    mounted: undefined|Function;\n\n    // One line methods...\n    getAllElements = (): Array<Element> => (typeof this.form === 'object') ? [...document.getElementById(this.form.id).children] : [...document.getElementById(this.form).children];\n    getInputValue = (elementId: string) => document.getElementById(elementId).value;\n    unmount = (): void => (typeof this.form === 'object') ? document.getElementById(this.form.id).remove() : window.__FORMJS__.warn('This form wasn\\'t created by FormJS but instead passed as an ID to the instance. Therefore, FormJS cannot remove it from the DOM. To have the ability to mount/unmount a form, create a new one by defining it on the `form` object. If you called this method via `destroy` the instance has however, been removed from the framework\\'s record of instances.');\n\n    /**\n     * Constructor\n     * @param {string} ref - form instance reference.\n     * @param {undefined|string} el - element to attach the form to.\n     * @param {string|Form} form - form object containing what the form needs to look like.\n     * @param {OnsubmitObject} onsubmit - onsubmit object containing what needs to happen when the form is submitted.\n     */\n    constructor(\n        ref: string,\n        el: undefined|string,\n        form: string|FormObject,\n        onsubmit: OnsubmitObject,\n        created: undefined|Function,\n        beforeMount: undefined|Function,\n        mounted: undefined|Function\n    )\n    {\n        // Set instance variables.\n        this.ref = ref;\n        this.el = el;\n        this.form = form;\n        this.onsubmit = onsubmit;\n        this.created = created;\n        this.beforeMount = beforeMount;\n        this.mounted = mounted;\n\n        // Once the instance is created, run the created hook if it exists.\n        if (this.created !== undefined) {\n            this.created();\n        }\n    }\n\n    /**\n     * Method to mount the form instance.\n     * @return {void}\n     */\n    mount(): void\n    {\n        // Create a new form instance.\n        const form = new Form(this.form, this.onsubmit, this.el);\n\n        // Run before mounted hook if it exists.\n        if (this.beforeMount !== undefined) {\n            this.beforeMount();\n        }\n\n        // If we have a form object then we will need to build the form.\n        if (typeof this.form === 'object') {\n            form.create().then(() => {\n                // Once the form is made, we need to create the internal\n                // elements...\n                form.createInternalElements(this.form['id']).then(() => {\n                    // Then we need to bind events to the form...\n                    form.bind().then(() => {\n                        // Run mounted hook if that exists.\n                        if (this.mounted !== undefined) {\n                            this.mounted();\n                        }\n                    })\n                });\n            });\n        }\n        // Else, if the form is already in the DOM, we just need to bind the\n        // onsubmit event to it.\n        else {\n            // Then we need to bind events to the form...\n            form.bind().then(() => {\n                if (this.mounted !== undefined) {\n                    this.mounted();\n                }\n            })\n        }\n    }\n\n    /**\n     * Method to destroy the instance.\n     * @return {void}\n     */\n    destroy(): void\n    {\n        // Remove from DOM.\n        this.unmount();\n        // Remove instance reference.\n        window.__FORMJS__.instances = window.__FORMJS__.instances.filter(current => current !== this);\n    }\n}\n","import { Version } from './lib/library';\nimport { Options } from './lib/options';\nimport { Instance } from './lib/instance';\nimport { Validator } from './lib/validator';\n\n/**\n * FormJS library entry point.\n */\nexport class FormJS\n{\n    options: FormJSOptions;\n    instances: Array<Instance> = [];\n\n    // One line methods...\n    validate: object = (el: string, rules: string) => new Validator().test({ el: el, rules: rules });\n    version = (): string => Version;\n    getInstances = (): Array<Instance> => [...this.instances];\n    error = (error: string): void => console.error(`[FORMJS ERROR] ${error}`);\n    warn = (warning: string): void => console.warn(`[FORM JS WARNING] ${warning}`);\n\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        window.__FORMJS__ = this;\n    }\n\n    /**\n     * Constructor to initialise the form instance.\n     * @param {Options} options - FormJS options.\n     * @return {Instance}\n     */\n    create = (options: FormJSOptions): Instance|MakeInstanceFailed =>\n    {\n        // Let's start creating the form...\n        try {\n            // Test options are as they need to be via the `Test` class.\n            Options.test(options, this.instances);\n\n            // Init a new instance.\n            const instance = new Instance(\n                options.ref,\n                options.el,\n                options.form,\n                options.onsubmit,\n                options.created,\n                options.beforeMount,\n                options.mounted\n            );\n\n            // Let's set our options so they're accessible in other API functions.\n            this.options = options;\n\n            // Lets push the created instance to the instances array so it can be\n            // accessed and modified.\n            this.instances.push(instance);\n\n            // Return instance.\n            return instance;\n        }\n\n        /**\n         * Error handling is done here for anything that went wrong above...\n         * @param {mixed} e\n         */\n        catch(e) {\n            // Throw error at time of failure.\n            this.error(e);\n\n            // Return an object with `mount` method which again, logs an error\n            // should it be called.\n            return {\n                mount() {\n                    window.__FORMJS__.error('You can\\'t mount an instance which failed to create.');\n                }\n            }\n        }\n    }\n}\n"],"names":["Version","RootOptionsStructure","requiredOptions","type","option","acceptedTypes","optional","type2","ElementOptionsStructure","Options","test","options","instances","testExistsAndTypes","ref","testIsUniqueInInstances","el","form","elements","length","forEach","element","context","payload","filter","instance","requiredOption","hasOwnProperty","JSON","stringify","typesCorrect","some","formData","validationsToMake","regexTests","name","pattern","RegExp","errorMessage","passed","failed","constructor","sortValidations","push","criteria","rules","result","validation","allCriteria","split","value","document","getElementById","includes","testMinLength","testMaxLength","testRegex","testIsDisposableEmail","then","response","testRequired","Promise","resolve","reject","attributes","id","validate","criteriaValue","parseInt","fetch","json","data","disposable","testName","fetchApiParams","onsubmit","wrappingEl","create","createElement","setAttribute","appendChild","createInternalElements","rootElement","formElement","innerHTML","text","key","Object","entries","bind","addEventListener","e","submit","blacklistedKeys","containsBlacklistedKey","blacklistedKey","preventDefault","before","includeFormData","fromEntries","FormData","target","url","method","body","success","catch","error","source","Validator","created","beforeMount","mounted","getAllElements","children","getInputValue","elementId","unmount","remove","window","__FORMJS__","warn","mount","Form","destroy","current","version","getInstances","console","warning","Instance"],"mappings":"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"}